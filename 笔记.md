State Hook
State Hook是一个在函数组件中使用的函数（useState），用于在函数组件中使用状态

useState

函数有一个参数，这个参数的值表示状态的默认值
函数的返回值是一个数组，该数组一定包含两项
第一项：当前状态的值
第二项：改变状态的函数
一个函数组件中可以有多个状态，这种做法非常有利于横向切分关注点。

注意的细节

useState最好写到函数的起始位置，便于阅读
useState严禁出现在代码块（判断、循环）中
useState返回的函数（数组的第二项），引用不变（节约内存空间）
使用函数改变数据，若数据和之前的数据完全相等（使用Object.is比较），不会导致重新渲染，以达到优化效率的目的。
使用函数改变数据，传入的值不会和原来的数据进行合并，而是直接替换。
如果要实现强制刷新组件
类组件：使用forceUpdate函数
函数组件：使用一个空对象的useState
如果某些状态之间没有必然的联系，应该分化为不同的状态，而不要合并成一个对象
和类组件的状态一样，函数组件中改变状态可能是异步的（在DOM事件中），多个状态变化会合并以提高效率，此时，不能信任之前的状态，而应该使用回调函数的方式改变状态。如果状态变化要使用到之前的状态，尽量传递函数。


Effect Hook
Effect Hook：用于在函数组件中处理副作用

副作用：

ajax请求
计时器
其他异步操作
更改真实DOM对象
本地存储
其他会对外部产生影响的操作
函数：useEffect，该函数接收一个函数作为参数，接收的函数就是需要进行副作用操作的函数

细节

副作用函数的运行时间点，是在页面完成真实的UI渲染之后。因此它的执行是异步的，并且不会阻塞浏览器
与类组件中componentDidMount和componentDidUpdate的区别
componentDidMount和componentDidUpdate，更改了真实DOM，但是用户还没有看到UI更新，同步的。
useEffect中的副作用函数，更改了真实DOM，并且用户已经看到了UI更新，异步的。
每个函数组件中，可以多次使用useEffect，但不要放入判断或循环等代码块中。
useEffect中的副作用函数，可以有返回值，返回值必须是一个函数，该函数叫做清理函数
该函数运行时间点，在每次运行副作用函数之前
首次渲染组件不会运行
组件被销毁时一定会运行
useEffect函数，可以传递第二个参数
第二个参数是一个数组
数组中记录该副作用的依赖数据
当组件重新渲染后，只有依赖数据与上一次不一样的时，才会执行副作用
所以，当传递了依赖数据之后，如果数据没有发生变化
副作用函数仅在第一次渲染后运行
清理函数仅在卸载组件后运行
副作用函数中，如果使用了函数上下文中的变量，则由于闭包的影响，会导致副作用函数中变量不会实时变化。
副作用函数在每次注册时，会覆盖掉之前的副作用函数，因此，尽量保持副作用函数稳定，否则控制起来会比较复杂。


自定义Hook
State Hook： useState Effect Hook：useEffect

自定义Hook：将一些常用的、跨越多个组件的Hook功能，抽离出去形成一个函数，该函数就是自定义Hook，自定义Hook，由于其内部需要使用Hook功能，所以它本身也需要按照Hook的规则实现：

函数名必须以use开头
调用自定义Hook函数时，应该放到顶层
例如：

很多组件都需要在第一次加载完成后，获取所有学生数据
很多组件都需要在第一次加载完成后，启动一个计时器，然后在组件销毁时卸载
使用Hook的时候，如果没有严格按照Hook的规则进行，eslint的一个插件（eslint-plugin-react-hooks）会报出警告
