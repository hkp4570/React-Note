# render props
有时候，某些组件的各种功能及其处理逻辑几乎完全相同，只是显示的界面不一样，建议下面的方式认选其一来解决重复代码的问题（横切关注点）

render props
某个组件，需要某个属性
该属性是一个函数，函数的返回值用于渲染
函数的参数会传递为需要的数据
注意纯组件的属性（尽量避免每次传递的render props的地址不一致）
通常该属性的名字叫做render
HOC

# 配置
# 额外的约定文件
- src/pages/document.ejs: 页面模板文件
- src/global.js：在umi最开始启动时运行的js文件
- src/app.js：作运行时配置的代码
- patchRoutes: 函数，该函数会在umi读取完所有静态路由配置后执行
- dva
- config： 相当于new dva(配置)
- plugins： 相当于dva.use(插件)


- .env: 配置环境变量，这些变量会在umi编译期间发挥作用
- UMI_ENV：umi的环境变量值，可以是任意值，该值会影响到.umirc.js,可以 指定开发模式下的配置文件，但是之后（生产环境）.umirc.js文件会覆盖该文件
- PORT    指定端口号
- MOCK    是否使用模拟数据，默认为开启


# .umirc配置
- umi配置
- 书写在.umirc.js文件中的配置

- plugins：配置umijs的插件
- routes：配置路由（会导致约定式路由失效）
- history：history对象模式（默认是browser）
- outputPath：使用umi build后，打包的目录名称，默认./dist
- base: 相当于之前BrowserRouter中的basename
- publicPath: 指定静态资源所在的目录
- exportStatic: 开启该配置后，会打包成多个静态页面，每个页面对应一个路由，开启多静态页面应用的前提条件是：没有动态路由
# webpack配置

#PureComponent

纯组件，用于避免不必要的渲染(渲染render函数)，从而提高效率
优化：如果一个组件的属性和状态都没有发生改变，重新渲染该组件是没有必要的

PureComponent是一个组件，如果某个组件继承自该组件，则该组件的shouldComponentUpdate会进行优化,
对属性和状态进行浅比较，如果相等则不会重新渲染

**注意**
PureComponent进行的是浅比较
1.为了效率，应该尽量使用PureComponent
2.要求不要改动之前的状态，永远是创建新的状态覆盖之前的状态(Immutable 不可变对象)
3.有一个第三方JS库，immutable.js，它专门用于制作不可变对象
函数组件，使用React.memo函数制作纯组件


# State Hook
- State Hook是一个在函数组件中使用的函数（useState），用于在函数组件中使用状态

useState
函数有一个参数，这个参数的值表示状态的默认值
函数的返回值是一个数组，该数组一定包含两项
第一项：当前状态的值
第二项：改变状态的函数

一个函数组件中可以有多个状态，这种做法非常有利于横向切分关注点。

**注意的细节**
- useState最好写到函数的起始位置，便于阅读
- useState严禁出现在代码块（判断、循环）中
- useState返回的函数（数组的第二项），引用不变（节约内存空间）
- 使用函数改变数据，若数据和之前的数据完全相等（使用Object.is比较），不会导致重新渲染，以达到优化效率的目的。
- 使用函数改变数据，传入的值不会和原来的数据进行合并，而是直接替换。
- 如果要实现强制刷新组件
- 类组件：使用forceUpdate函数
- 函数组件：使用一个空对象的useState
- 如果某些状态之间没有必然的联系，应该分化为不同的状态，而不要合并成一个对象
- 和类组件的状态一样，函数组件中改变状态可能是异步的（在DOM事件中），多个状态变化会合并以提高效率，此时，不能信任之前的状态，而应该使用回调函数的方式改变状态。如果状态变化要使用到之前的状态，尽量传递函数。

# useEffect

Effect Hook
Effect Hook：用于在函数组件中处理副作用

副作用：

ajax请求
计时器
其他异步操作
更改真实DOM对象
本地存储
其他会对外部产生影响的操作
函数：useEffect，该函数接收一个函数作为参数，接收的函数就是需要进行副作用操作的函数

细节

副作用函数的运行时间点，是在页面完成真实的UI渲染之后。因此它的执行是异步的，并且不会阻塞浏览器
与类组件中componentDidMount和componentDidUpdate的区别
componentDidMount和componentDidUpdate，更改了真实DOM，但是用户还没有看到UI更新，同步的。
useEffect中的副作用函数，更改了真实DOM，并且用户已经看到了UI更新，异步的。
每个函数组件中，可以多次使用useEffect，但不要放入判断或循环等代码块中。
useEffect中的副作用函数，可以有返回值，返回值必须是一个函数，该函数叫做清理函数
该函数运行时间点，在每次运行副作用函数之前
首次渲染组件不会运行
组件被销毁时一定会运行
useEffect函数，可以传递第二个参数
第二个参数是一个数组
数组中记录该副作用的依赖数据
当组件重新渲染后，只有依赖数据与上一次不一样的时，才会执行副作用
所以，当传递了依赖数据之后，如果数据没有发生变化
副作用函数仅在第一次渲染后运行
清理函数仅在卸载组件后运行
副作用函数中，如果使用了函数上下文中的变量，则由于闭包的影响，会导致副作用函数中变量不会实时变化。
副作用函数在每次注册时，会覆盖掉之前的副作用函数，因此，尽量保持副作用函数稳定，否则控制起来会比较复杂。
