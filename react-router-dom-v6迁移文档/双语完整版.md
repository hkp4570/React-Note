# Upgrading from v5 中英文双语文档

> 原文链接：*https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md*



## Backwards Compatibility Package（向后兼容包）

We are actively working on a backwards compatibility layer that implements the v5 API on top of the v6 implementation. This will make upgrading as smooth as possible. You'll be able to upgrade to v6 with minimal changes to your application code. Then, you can incrementally update your code to the v6 API.

我们正在积极致力于在 v6 的基础上实现 v5 API 的向后兼容层。这将使开发者们的升级尽可能的平滑和顺利。您只需对应用程序代码进行很少的更改即可升级到 v6。然后，您可以逐步将代码更新到 v6 API。



We recommend waiting for the backwards compatibility package to be released before upgrading apps that have more than a few routes.

我们建议开发者先等待向后兼容包发布之后再升级具有多个路由的应用程序。



Until then, we hope this guide will help you do the upgrade all at once!

在此之前，我们希望本指南能帮助您一次性成功并且顺利的完成升级！



## Introduction（介绍）

React Router version 6 introduces several powerful new features, as well as improved compatibility with the latest versions of React. It also introduces a few breaking changes from version 5. This document is a comprehensive guide on how to upgrade your v4/5 app to v6 while hopefully being able to ship as often as possible as you go.

React Router 版本 6 引入了几个强大的新功能，并改进了与最新版本的 React 的兼容性。它还引入了 v5 的一些重大更新。本文档用于指导开发人员如何将自己的应用程序从 v4/5 到 v6 ，目的是为了让大家能够尽可能更快的用上最新的版本。



If you are just getting started with React Router, or you'd like to try out v6 in a new app, please see [the Getting Started guide](https://github.com/remix-run/react-router/blob/main/docs/getting-started/installation.md).

如果你刚刚开始使用React Router，或者你想在一个新的应用中试用v6，请参阅[入门指南](https://github.com/remix-run/react-router/blob/main/docs/getting-started/installation.md)。



The examples in this guide will show code samples of how you might have built something in a v5 app, followed by how you would accomplish the same thing in v6. There will also be an explanation of why we made this change and how it's going to improve both your code and the overall user experience of people who are using your app.

本指南中的示例首先将展示在v5版本的应用程序中构建某些东西的代码，然后演示如何在v6中完成相同的事情。并且本指南还将解释我们进行此更新的原因以及它将如何改进您的代码以及应用程序整体的用户体验。



In general, the process looks like this:

1. [Upgrade to React v16.8 or greater](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#upgrade-to-react-v168)

2. [Upgrade to React Router v5.1](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#upgrade-to-react-router-v51)

3. - [Remove `<Redirect>` s inside `<Switch>` ](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#remove-redirects-inside-switch)
   - [Refactor custom `<Route>` s](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#refactor-custom-routes)

4. [Upgrade to React Router v6](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#upgrade-to-react-router-v6)

一般来说，整个过程是这样的：

1. [升级到 React v16.8 或更高版本](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#upgrade-to-react-v168)
2. [升级到 React Router v5.1](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#upgrade-to-react-router-v51)
3. [升级到 React Router v6](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#upgrade-to-react-router-v6)



The following is a detailed breakdown of each step that should help you migrate quickly and with confidence to v6.

以下是每个步骤的详细分类，可帮助您快速地迁移到 v6。



## Upgrade to React v16.8（升级到 React v16.8）

React Router v6 makes heavy use of [React hooks](https://reactjs.org/docs/hooks-intro.html), so you'll need to be on React 16.8 or greater before attempting the upgrade to React Router v6. The good news is that React Router v5 is compatible with React >= 15, so if you're on v5 (or v4) you should be able to upgrade React without touching any of your router code.

React Router v6 大量使用 [React hooks](https://reactjs.org/docs/hooks-intro.html)，因此在尝试升级到 React Router v6 之前，您需要使用 React 16.8 或更高版本。好消息是 React Router v5 与 React >= 15 兼容，因此如果您使用的是 v5（或 v4），您应该能够在不修改任何路由器代码的情况下升级 React。



Once you've upgraded to React 16.8, **you should deploy your app**. Then you can come back later and pick up where you left off.

升级到 React 16.8 后，**你应该部署你的应用程序**。 然后，您可以稍后再回到本指南从上次中断的地方继续。



## Upgrade to React Router v5.1（升级到 React Router v5.1）

It will be easier to make the switch to React Router v6 if you upgrade to v5.1 first. In v5.1, we released an enhancement to the handling of `<Route children>` elements that will help smooth the transition to v6. Instead of using `<Route component>` and `<Route render>` props, just use regular element `<Route children>` everywhere and use hooks to access the router's internal state.

如果您先升级到 v5.1，则切换到 React Router v6 会更容易。在 v5.1 中，我们发布了对 `<Route children>` 元素的增强，这将有助于平滑过渡到 v6。不用使用 `<Route component>` 和 `<Route render>` props，只需在任何地方使用常规元素 `<Route children>` 并使用hook就能够访问路由器的内部状态。

```js
// v4 and v5 before 5.1
function User({ id }) {
  // ...
}

function App() {
  return (
    <Switch>
      <Route exact path="/" component={Home} />
      <Route path="/about" component={About} />
      <Route
        path="/users/:id"
        render={({ match }) => (
          <User id={match.params.id} />
        )}
      />
    </Switch>
  );
}

// v5.1 preferred style
function User() {
  let { id } = useParams();
  // ...
}

function App() {
  return (
    <Switch>
      <Route exact path="/">
        <Home />
      </Route>
      <Route path="/about">
        <About />
      </Route>
      {/* Can also use a named `children` prop */}
      <Route path="/users/:id" children={<User />} />
    </Switch>
  );
}
```

You can read more about v5.1's hooks API and the rationale behind the move to regular elements [on our blog](https://reacttraining.com/blog/react-router-v5-1/).

您可以[在我们的博客上](https://reacttraining.com/blog/react-router-v5-1/)阅读更多关于 v5.1 的 hooks API 以及迁移到常规元素背后的基本原理 



In general, React Router v5.1 (and v6) favors elements over components (or "element types"). There are a few reasons for this, but we'll discuss more further down when we discuss v6's `<Route>` API.

一般来说，React Router v5.1（包括 v6）中更多的使用元素而非组件（或“元素类型”）。这有几个原因，后面当我们讨论 v6 的 `<Route>` API 时，我们将做进一步讨论。



When you use regular React elements you get to pass the props explicitly. This helps with code readability and maintenance over time. If you were using `<Route render>` to get a hold of the params, you can just `useParams` inside your route component instead.

当你使用常规的 React 元素时，你可以显式地传递 props。从长远来看，这有助于提升代码的可读性和维护性。如果你使用 `<Route render>` 来获取参数，你可以在你的路由组件中只使用 `useParams`。



Along with the upgrade to v5.1, you should replace any usage of `withRouter` with hooks. You should also get rid of any "floating" `<Route>` elements that are not inside a `<Switch>`. Again, [the blog post about v5.1](https://reacttraining.com/blog/react-router-v5-1/) explains how to do this in greater detail.

随着升级到 v5.1，您应该用hook来替换其他任何地方使用到的 `withRouter`。您还应该避免任何不在 `<Switch>` 内的“浮动”`<Route>` 元素。（备注：换句话说，所有的 `<Route>` 都应该放在`<Switch>`中）同样，[关于v5.1的博客文章](https://reacttraining.com/blog/react-router-v5-1/)更详细地解释了如何做到这一点。



In summary, to upgrade from v4/5 to v5.1, you should:

- Use `<Route children>` instead of `<Route render>` and/or `<Route component>` props
- Use [our hooks API](https://reacttraining.com/react-router/web/api/Hooks) to access router state like the current location and params
- Replace all uses of `withRouter` with hooks
- Replace any `<Route>`s that are not inside a `<Switch>` with `useRouteMatch`, or wrap them in a `<Switch>`

总之，要从 v4/5 升级到 v5.1，您应该：

- 使用 `<Route children>` 而不是 `<Route render>` 或者 `<Route component>` props
- 使用 [hooks API](https://reacttraining.com/react-router/web/api/Hooks) 访问路由器状态，例如获取当前位置和参数
- 用hook替换所有使用 `withRouter` 的地方
- 用 `useRouteMatch` 替换任何不在 `<Switch>` 中的 `<Route>`，或者将它们包装在 `<Switch>` 中



### Remove `<Redirect>`s inside `<Switch>`（移除 `<Switch>` 中的 `<Redirect>`）

Remove any `<Redirect>` elements that are directly inside a `<Switch>`.

删除在 `<Switch>` 内所有的 `<Redirect>` 元素。



If you want to redirect on the initial render, you should move the redirect logic to your server (we [wrote more about this here](https://gist.github.com/mjackson/b5748add2795ce7448a366ae8f8ae3bb)).

如果你想在初始渲染的时候进行重定向，那么你应该将重定向逻辑转移到你的服务器(我们[在这里写了更多相关内容](https://gist.github.com/mjackson/b5748add2795ce7448a366ae8f8ae3bb))。



If you want to redirect client-side, move your `<Redirect>` into a `<Route render>` prop.

如果您想在客户端进行重定向，请将您的 `<Redirect>` 移动到 `<Route render>` 的 prop 中。

```js
// Change this:
<Switch>
  <Redirect from="about" to="about-us" />
</Switch>

// to this:
<Switch>
  <Route path="about" render={() => <Redirect to="about-us" />} />
</Switch>
```

Normal `<Redirect>` elements that are not inside a `<Switch>` are ok to remain. They will become `<Navigate>` elements in v6.

不在 `<Switch>` 中的普通 `<Redirect>` 元素可以保留。它们将在 v6 中成为 `<Navigate>` 元素。



### Refactor custom `<Route>`s（重构自定义`<Route>`s）

Replace any elements inside a `<Switch>` that are not plain `<Route>` elements with a regular `<Route>`. This includes any `<PrivateRoute>`-style custom components.

用常规的 `<Route>` 替换 `<Switch>` 中任何一个非 `<Route>` 元素。这种替换包括了诸如 `<PrivateRoute>` 这样的自定义样式组件。



You can [read more about the rationale behind this here](https://gist.github.com/mjackson/d54b40a094277b7afdd6b81f51a0393f), including some tips about how to use a `<Route render>` prop in v5 to achieve the same effect.

你可以 [在这里阅读更多关于这背后的基本原理](https://gist.github.com/mjackson/d54b40a094277b7afdd6b81f51a0393f)，包括一些关于如何在 v5 中使用 `<Route render>` 属性来实现相同效果的提示。



### Ship it!（用起来！）

Again, **once your app is upgraded to v5.1 you should test and deploy it**, and pick this guide back up when you're ready to continue.

同样，**一旦您的应用升级到了 v5.1，您应该对其进行测试和部署**，并在您准备好继续前进时回来本指南。



## Upgrade to React Router v6（升级到 React Router v6）

**Heads up:** This is the biggest step in the migration and will probably take the most time and effort.

**注意：** 这是迁移中跨度最大的一步，可能会花费很多的时间和精力。

For this step, you'll need to install React Router v6. If you're managing dependencies via npm:

首先第一步，您需要安装 React Router v6。 假设您通过 npm 管理依赖项，那么可以输入如下的指令：

```bash
$ npm install react-router-dom
# or, for a React Native app
$ npm install react-router-native
```

You'll also want to remove the `history` dependency from your package.json. The `history` library is a direct dependency of v6 (not a peer dep), so you won't ever import or use it directly. Instead, you'll use the `useNavigate()` hook for all navigation (see below).

你还需要从你的 package.json 中移除 `history` 依赖。`history` 库现在已经变成了 v6 的直接依赖项（而非以前的 peer 依赖），因此您永远不会涉及到直接导入或使用它。相反，您将在所有的导航中使用 `useNavigate()` 这个hook（见下文）。



### Upgrade all `<Switch>` elements to `<Routes>`（将所有 `<Switch>` 元素升级为 `<Routes>`）

React Router v6 introduces a `Routes` component that is kind of like `Switch`, but a lot more powerful. The main advantages of `Routes` over `Switch` are:

- All `<Route>`s and `<Link>`s inside a `<Routes>` are relative. This leads to leaner and more predictable code in `<Route path>` and `<Link to>`
- Routes are chosen based on the best match instead of being traversed in order. This avoids bugs due to unreachable routes because they were defined later in your `<Switch>`
- Routes may be nested in one place instead of being spread out in different components. In small to medium-sized apps, this lets you easily see all your routes at once. In large apps, you can still nest routes in bundles that you load dynamically via `React.lazy`

React Router v6 引入了一个类似于 `Switch` 的 `Routes` 组件，但功能更强大。 `Routes` 相对于 `Switch` 的主要优点有：

- `<Routes>` 中的所有 `<Route>` 和 `<Link>` 都是相对的。 这就让 `<Route path>` 和 `<Link to>` 中的代码更加简洁和可预测
- 路由是根据最佳匹配来选择的，而不是像之前那样按顺序遍历。这避免了由于路由未匹配上而导致的错误，因为它们之后都会在您的`<Switch>`中进行定义
- 路由可以嵌套在一个地方，而不是分散在不同的组件中。在中小型应用程序中，这使您可以轻松地一次查看所有的路由。 在大型应用程序中，您仍然可以将路由嵌套在通过 React.lazy 动态加载的包中



In order to use v6, you'll need to convert all your `<Switch>` elements to `<Routes>`. If you already made the upgrade to v5.1, you're halfway there.

使用 v6，您需要将所有 `<Switch>` 元素转换为 `<Routes>`。如果您已经升级到了 v5.1，那么恭喜您，您已经完成了一半。



First, let's talk about relative routes and links in v6.

首先让我们来说一下v6中的相对路由和链接。



### Relative Routes and Links（相对的Routes和Links）

In v5, you had to be very explicit about how you wanted to nest your routes and links. In both cases, if you wanted nested routes and links you had to build the `<Route path>` and `<Link to>` props from the parent route's `match.url` and `match.path` properties. Additionally, if you wanted to nest routes, you had to put them in the child route's component.

在 v5 中，您必须非常明确地说明要如何嵌套路由和链接。在这两种情况下，如果你想要嵌套路由和链接，你必须从父路由的 `match.url` 和 `match.path` 属性中构建 `<Route path>` 和 `<Link to>` 属性。此外，如果您想嵌套路由，则必须将它们放在子路由的组件中。

```js
// This is a React Router v5 app
// 这是一个 React Router v5 应用程序
import {
  BrowserRouter,
  Switch,
  Route,
  Link,
  useRouteMatch,
} from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Switch>
        <Route exact path="/">
          <Home />
        </Route>
        <Route path="/users">
          <Users />
        </Route>
      </Switch>
    </BrowserRouter>
  );
}

function Users() {
  // In v5, nested routes are rendered by the child component, so
  // you have <Switch> elements all over your app for nested UI.
  // You build nested routes and links using match.url and match.path.
  // 在 v5 中，嵌套路由由子组件呈现，因此在您的整个应用程序中都有用于嵌套 UI 的 <Switch> 元素。您可以使用 match.url 和 match.path 来构建嵌套路由和链接。
  let match = useRouteMatch();

  return (
    <div>
      <nav>
        <Link to={`${match.url}/me`}>My Profile</Link>
      </nav>

      <Switch>
        <Route path={`${match.path}/me`}>
          <OwnUserProfile />
        </Route>
        <Route path={`${match.path}/:id`}>
          <UserProfile />
        </Route>
      </Switch>
    </div>
  );
}
```

This is the same app in v6:

这是使用v6构建的同一个应用程序：

```js
// This is a React Router v6 app
// 这是一个 React Router v6 应用
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
} from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="users/*" element={<Users />} />
      </Routes>
    </BrowserRouter>
  );
}

function Users() {
  return (
    <div>
      <nav>
        <Link to="me">My Profile</Link>
      </nav>

      <Routes>
        <Route path=":id" element={<UserProfile />} />
        <Route path="me" element={<OwnUserProfile />} />
      </Routes>
    </div>
  );
}
```

A few important things to notice about v6 in this example:

- `<Route path>` and `<Link to>` are relative. This means that they automatically build on the parent route's path and URL so you don't have to manually interpolate `match.url` or `match.path`
- `<Route exact>` is gone. Instead, routes with descendant routes (defined in other components) use a trailing `*` in their path to indicate they match deeply
- You may put your routes in whatever order you wish and the router will automatically detect the best route for the current URL. This prevents bugs due to manually putting routes in the wrong order in a `<Switch>`

在此示例中，关于构建 v6 版本时需要注意的一些重要事项：

- `<Route path>` 和 `<Link to>` 是相对的。 这意味着它们会自动构建在父路由的路径和 URL 上，因此您不必手动插入 `match.url` 或 `match.path`
- `<Route exact>` 消失了。 相反，（在其他组件中定义的）具有后代路由的路由在其路径中使用 `*` 表示它们深度匹配
- 您可以按照您希望的任何顺序放置您的路由，路由器将自动检测当前 URL 的最佳路由。这可以防止由于手动将路由以错误的顺序放置在 `<Switch>` 中而导致的错误



You may have also noticed that all `<Route children>` from the v5 app changed to `<Route element>` in v6. Assuming you followed the upgrade steps to v5.1, this should be as simple as moving your route element from the child position to a named `element` prop.

您可能还注意到 v5 应用程序中的所有 `<Route children>` 在 v6 中都更改为了 `<Route element>`。假设您遵循升级步骤已经升级到了 v5.1，那么这就基本类似于将路由元素重命名为`element` prop 一样简单。



### Advantages of `<Route element>`（`<Route element>`的优点）

In the section about upgrading to v5.1, we promised that we'd discuss the advantages of using regular elements instead of components (or element types) for rendering. Let's take a quick break from upgrading and talk about that now.

在关于升级到 v5.1 的部分中，有讲过我们将讨论使用常规元素而不是组件（或元素类型）进行渲染的优势。让我们在升级的教程中稍微休息一下，现在就来讨论一下其优势。



For starters, we see React itself taking the lead here with the `<Suspense fallback={<Spinner />}>` API. The `fallback` prop takes a React element, not a component. This lets you easily pass whatever props you want to your `<Spinner>` from the component that renders it.

对于初学者，我们看到 React 本身有一个 `<Suspense fallback={<Spinner />}>` API 。`fallback` 属性接受一个 React 元素，而不是一个组件。这让您可以轻松地将所需的任何props从渲染它的组件上传递给您的`<Spinner>`。



Using elements instead of components means we don't have to provide a `passProps`-style API so you can get the props you need to your elements. For example, in a component-based API there is no good way to pass props to the `<Profile>` element that is rendered when `<Route path=":userId" component={Profile} />` matches. Most React libraries who take this approach end up with either an API like `<Route component={Profile} passProps={{ animate: true }} />` or use a render prop or higher-order component.

使用元素而非组件意味着我们不必提供“passProps”风格的 API您就可以获得元素所需的props。例如，在基于组件的 API 中，当匹配`<Route path=":userId" component={Profile} />` 时，没有什么好的方法能够传递props给 `<Profile>` 元素。大多数第三方 React 库最终要么使用类似 `<Route component={Profile} passProps={{ animate: true }} />` 的 API，要么使用 render prop 或更高阶的组件。



Also, in case you didn't notice, in v4 and v5 `Route`'s rendering API became rather large. It went something like this:

另外，可能您没有注意到，在 v4 和 v5 中，`Route` 的渲染 API 变得相当大。 它大概是这样的：

```js
// Ah, this is nice and simple!
// 啊，这很好，很简单！
<Route path=":userId" component={Profile} />

// But wait, how do I pass custom props to the <Profile> element??
// 但是等等，我如何将自定义props传递给 <Profile> 元素？
// Hmm, maybe we can use a render prop in those situations?
// 嗯，也许我们可以在这些情况下使用 render prop？
<Route
  path=":userId"
  render={routeProps => (
    <Profile routeProps={routeProps} animate={true} />
  )}
/>

// Ok, now we have two ways to render something with a route. :/
// 好的，现在我们有两种方法可以用路由渲染一些东西。 ：/

// But wait, what if we want to render something when a route
// 但是等等，如果我们想在路由时渲染一些东西怎么办？
// *doesn't* match the URL, like a Not Found page? Maybe we
// can use another render prop with slightly different semantics?
// 与 URL 不匹配，例如 Not Found 页面？ 也许我们可以使用另一个语义稍有不同的 render prop？
<Route
  path=":userId"
  children={({ match }) => (
    match ? (
      <Profile match={match} animate={true} />
    ) : (
      <NotFound />
    )
  )}
/>

// What if I want to get access to the route match, or I need
// to redirect deeper in the tree?
// 如果我想访问路由匹配，或者我需要在树中深层重定向怎么办？
function DeepComponent(routeStuff) {
  // got routeStuff, phew!
  // 得到了 routeStuff，呸！
}
export default withRouter(DeepComponent);

// Well hey, now at least we've covered all our use cases!
// 好吧，现在至少我们已经涵盖了所有用例！
// ... *facepalm*
// ... *捂脸*
```

At least part of the reason for this API sprawl was that React did not provide any way for us to get the information from the `<Route>` to your route element, so we had to invent clever ways to get both the route data **and** your own custom props through to your elements: `component`, render props, `passProps` higher-order-components ... until **hooks** came along!

导致这个API蔓延的一个最基本原因是因为 React 没有提供任何方法让我们从 `<Route>` 获取信息到你的路由元素，因此我们必须使用一些巧妙的方法来获取路由数据**以及**从元素中获取自定义props：`component`，render props，`passProps`高阶组件......直到 hooks 的出现，改变了这一切！



Now, the conversation above goes like this:

现在，上面的对话就变成了这样：

```js
// Ah, nice and simple API. And it's just like the <Suspense> API!
// 啊，非常棒而且很简单的 API。 它就像 <Suspense> API！
// Nothing more to learn here.
// 不需要学习额外的东西
<Route path=":userId" element={<Profile />} />

// But wait, how do I pass custom props to the <Profile>
// 但是等等，我如何将自定义 props 传递给 <Profile>
// element? Oh ya, it's just an element. Easy.
// 元素？哦，对的，这只是一个元素。太简单了。
<Route path=":userId" element={<Profile animate={true} />} />

// Ok, but how do I access the router's data, like the URL params
// 好的，但是我如何访问路由器的数据，例如 URL 参数
// or the current location?
// 或者访问当前位置
function Profile({ animate }) {
  let params = useParams();
  let location = useLocation();
}

// But what about components deep in the tree?
// 但是在一个树结构中我要访问根部组件呢？
function DeepComponent() {
  // oh right, same as anywhere else
  // 哦，对了，这也和和其他地方一样
  let navigate = useNavigate();
}

// Aaaaaaaaand we're done here.
// 哈哈哈哈哈哈哈，到此结束（太棒了～）
```

Another important reason for using the `element` prop in v6 is that `<Route children>` is reserved for nesting routes. This is one of people's favorite features from v3 and `@reach/router`, and we're bringing it back in v6. Taking the code in the previous example one step further, we can hoist all `<Route>` elements into a single route config:

在 v6 中使用 `element` 属性的另一个重要原因是 `<Route children>` 是为嵌套路由保留的。这是 v3 和 `@reach/router` 中人们最喜欢的功能之一，我们将在 v6 中使其回归。接下来在上一个示例代码的基础上更进一步，我们可以将所有 `<Route>` 元素提升到单个路由配置中：

```js
// This is a React Router v6 app
// 这是一个 React Router v6 应用
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
  Outlet,
} from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="users" element={<Users />}>
          <Route path="me" element={<OwnUserProfile />} />
          <Route path=":id" element={<UserProfile />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

function Users() {
  return (
    <div>
      <nav>
        <Link to="me">My Profile</Link>
      </nav>

      <Outlet />
    </div>
  );
}
```

This step is optional of course, but it's really nice for small to medium sized apps that don't have thousands of routes.

这一步当然是可选的，并且对于那种没有上千个路由的中小型应用程序来说，这一点确实很棒。



Notice how `<Route>` elements nest naturally inside a `<Routes>` element. Nested routes build their path by adding to the parent route's path. We didn't need a trailing `*` on `<Route path="users">` this time because when the routes are defined in one spot the router is able to see all your nested routes.

注意一下 `<Route>` 元素是如何自然嵌套在 `<Routes>` 元素中的。嵌套路由通过添加到父路由的路径来构建它们的路径。这次我们不需要在 `<Route path="users">` 上使用尾随 `*`，因为当在一个位置定义路由时，路由器能够看到所有嵌套路由。



You'll only need the trailing `*` when there is another `<Routes>` somewhere in that route's descendant tree. In that case, the descendant `<Routes>` will match on the portion of the pathname that remains (see the previous example for what this looks like in practice).

当该路由的后代树中某处有另一个 `<Routes>` 时，您只需要添加一个 `*`。在这种情况下，后代 `<Routes>` 将匹配保留的路径名部分（请参阅前面的示例以了解实际情况）。



When using a nested config, routes with `children` should render an `<Outlet>` in order to render their child routes. This makes it easy to render layouts with nested UI.

使用嵌套配置时，带有 `children` 的路由应渲染 `<Outlet>` 以达到渲染其子路由的效果。这样的设计使得使用嵌套 UI 渲染布局变得容易。



### Note on `<Route path>` patterns（`<Route path>` 模式的注意事项）

React Router v6 uses a simplified path format. `<Route path>` in v6 supports only 2 kinds of placeholders: dynamic `:id`-style params and `*` wildcards. A `*` wildcard may be used only at the end of a path, not in the middle.

React Router v6 使用简化的路径格式。 v6 中的 `<Route path>` 仅支持 2 种占位符：动态 `:id` 样式的参数和 `*` 通配符。 `*` 通配符只能用在路径的末尾，不能用在中间。

All of the following are valid route paths in v6:

以下都是 v6 中的有效路由路径：

```bash
/groups
/groups/admin
/users/:id
/users/:id/messages
/files/*
/files/:id/*
```

The following RegExp-style route paths are **not valid** in v6:

以下正则风格的路由路径在 v6 中**无效**：

```bash
/users/:id?
/tweets/:id(\d+)
/files/*/cat.jpg
/files-*
```

We added the dependency on path-to-regexp in v4 to enable more advanced pattern matching. In v6 we are using a simpler syntax that allows us to predictably parse the path for ranking purposes. It also means we can stop depending on path-to-regexp, which is nice for bundle size.

我们在 v4 中添加了对 path-to-regexp 的依赖，以启用更高级的模式进行匹配。在 v6 中，我们使用了一种更简单的语法，它允许我们以可预测的方式解析路径以便于进行排列。这也意味着我们可以停止依赖正则表达式的路由路径，这有助于优化打包后的包大小。



If you were using any of path-to-regexp's more advanced syntax, you'll have to remove it and simplify your route paths. If you were using the RegExp syntax to do URL param validation (e.g. to ensure an id is all numeric characters) please know that we plan to add some more advanced param validation in v6 at some point. For now, you'll need to move that logic to the component the route renders, and let it branch it's rendered tree after you parse the params.

如果您使用的是 path-to-regexp 的任何更高级的语法，则必须将其删除并简化您的路由路径。如果您使用 RegExp 语法进行 URL 参数验证（例如，确保 id 全部都是数字字符），那么请知道我们计划在将来的某个时候在 v6 中添加一些更高级的参数验证。但是就目前而言，您需要将该逻辑移至路由渲染的组件，并在解析参数后分支渲染树。



If you were using `<Route sensitive>` you should move it to its containing `<Routes caseSensitive>` prop. Either all routes in a `<Routes>` element are case-sensitive or they are not.

如果你使用的是 `<Routesensitive>`，你应该将它移动到它包含的 `<Routes caseSensitive>` 属性中。`<Routes>` 元素中的所有路由要么区分大小写，要么不区分大小写。



One other thing to notice is that all path matching in v6 ignores the trailing slash on the URL. In fact, `<Route strict>` has been removed and has no effect in v6. **This does not mean that you can't use trailing slashes if you need to.** Your app can decide to use trailing slashes or not, you just can't render two different UIs *client-side* at `<Route path="edit">` and `<Route path="edit/">`. You can still render two different UIs at those URLs (though we wouldn't recommend it), but you'll have to do it server-side.

需要注意的另一件事是，v6 中的所有路径匹配都会忽略 URL 上的尾部斜杠。事实上，`<Route strict>` 已经被移除，在 v6 中没有任何作用。**当然这并不意味着您不能使用斜杠。**您的应用可以自行决定是否要使用斜杠，只是因为会忽略斜杠，因此 `<Route path="edit">` 和 `<Route path="edit/">` 并没有什么区别，会呈现相同的 UI。如果你想在这些 URL 上呈现两个不同的 UI（尽管我们不建议这样做），那么您必须在服务器端进行一些处理。



### Note on `<Link to>` values（`<Link to>` 值的注意事项）

In v5, a `<Link to>` value that does not begin with `/` was ambiguous; it depends on what the current URL is. For example, if the current URL is `/users`, a v5 `<Link to="me">` would render a `<a href="/me">`. However, if the current URL has a trailing slash, like `/users/`, the same `<Link to="me">` would render `<a href="/users/me">`. This makes it difficult to predict how links will behave, so in v5 we recommended that you build links from the root URL (using `match.url`) and not use relative `<Link to>` values.

在 v5 中，不以 `/` 开头的 `<Link to>` 值是不明确的；这取决于当前的 URL 是什么。例如，如果当前 URL 是 `/users`，则 v5 `<Link to="me">` 将呈现 `<a href="/me">`。但是，如果当前 URL 有一个尾部斜杠，例如 `/users/`，则相同的 `<Link to="me">` 将呈现 `<a href="/users/me">`。这使得我们很难预测链接的行为方式，因此在 v5 中，我们建议您从根 URL（使用 `match.url`）构建链接，而不是使用相对的 `<Link to>` 值。



React Router v6 fixes this ambiguity. In v6, a `<Link to="me">` will always render the same `<a href>`, regardless of the current URL.

React Router v6 修复了这种歧义。 在 v6 中，`<Link to="me">` 将始终呈现相同的 `<a href>`，无论当前 URL 是什么。



For example, a `<Link to="me">` that is rendered inside a `<Route path="users">` will always render a link to `/users/me`, regardless of whether or not the current URL has a trailing slash.

例如，在 `<Route path="users">` 中呈现的 `<Link to="me">` 将始终呈现指向 `/users/me` 的链接，无论当前 URL 是否有一个尾部斜杠。



When you'd like to link back "up" to parent routes, use a leading `..` segment in your `<Link to>` value, similar to what you'd do in a `<a href>`.

当您想“向上”链接到父路由时，请在 `<Link to>` 值中使用表示上一级目录的 `..` ，类似于你在 `<a href>` 中选择相对路径时所做的。

```react
function App() {
  return (
    <Routes>
      <Route path="users" element={<Users />}>
        <Route path=":id" element={<UserProfile />} />
      </Route>
    </Routes>
  );
}

function Users() {
  return (
    <div>
      <h2>
        {/* This links to /users - the current route */}
        <Link to=".">Users</Link>
      </h2>

      <ul>
        {users.map((user) => (
          <li>
            {/* This links to /users/:id - the child route */}
            <Link to={user.id}>{user.name}</Link>
          </li>
        ))}
      </ul>
    </div>
  );
}

function UserProfile() {
  return (
    <div>
      <h2>
        {/* This links to /users - the parent route */}
        <Link to="..">All Users</Link>
      </h2>

      <h2>
        {/* This links to /users/:id - the current route */}
        <Link to=".">User Profile</Link>
      </h2>

      <h2>
        {/* This links to /users/mj - a "sibling" route */}
        <Link to="../mj">MJ</Link>
      </h2>
    </div>
  );
}
```

It may help to think about the current URL as if it were a directory path on the filesystem and `<Link to>` like the `cd` command line utility.

将当前 URL 视为文件系统上的目录路径以及像 `cd` 命令行一样，这样的话 `<Link to>` 可能会更便于你理解一些。

```react
// If your routes look like this
// 如果您的路由看起来像这样
<Route path="app">
  <Route path="dashboard">
    <Route path="stats" />
  </Route>
</Route>

// and the current URL is /app/dashboard (with or without
// a trailing slash)
// 当前 URL 是 /app/dashboard （不管有没有斜杠）
<Link to="stats">               => <a href="/app/dashboard/stats">
<Link to="../stats">            => <a href="/app/stats">
<Link to="../../stats">         => <a href="/stats">
<Link to="../../../stats">      => <a href="/stats">

// On the command line, if the current directory is /app/dashboard
// 在命令行上，如果当前目录是 /app/dashboard
cd stats                        # pwd is /app/dashboard/stats
cd ../stats                     # pwd is /app/stats
cd ../../stats                  # pwd is /stats
cd ../../../stats               # pwd is /stats
```

**Note**: The decision to ignore trailing slashes while matching and creating relative paths was not taken lightly by our team. We consulted with a number of our friends and clients (who are also our friends!) about it. We found that most of us don't even understand how plain HTML relative links are handled with the trailing slash. Most people guessed it worked like `cd` on the command line (it does not). Also, HTML relative links don't have the concept of nested routes, they only worked on the URL, so we had to blaze our own trail here a bit. `@reach/router` set this precedent and it has worked out well for a couple of years.

**注意**：在匹配和创建相对路径时忽略尾部斜杠的决定并不是我们团队一个草率的决定。我们咨询了我们的一些朋友和客户（客户也是我们的朋友！）。我们发现，大多数人甚至不了解如何使用尾部斜杠处理纯 HTML 相对链接。大多数人猜测它和命令行上的 `cd` 类似（但实际上当时的它并没有）。另外，HTML 相对链接没有嵌套路由的概念，它们只对 URL 起作用，所以我们不得不在这里创建一套我们自己的规则。`@reach/router` 开创了这个先例，并且已经运行了好几年。



In addition to ignoring trailing slashes in the current URL, it is important to note that `<Link to="..">` will not always behave like `<a href="..">` when your `<Route path>` matches more than one segment of the URL. Instead of removing just one segment of the URL, **it will resolve based upon the parent route's path, essentially removing all path segments specified by that route**.

除了忽略当前 URL 中的尾部斜杠之外，还有一个非常值得注意的地方，那就是当您的 `<Route path >` 匹配多个 URL 段。**它会根据父路由的路径进行解析，删除该路由指定的所有路径段，而不是只删除 URL 的一部分**。



```react
function App() {
  return (
    <Routes>
      <Route path="users">
        <Route
          path=":id/messages"
          element={
            // This links to /users
            <Link to=".." />
          }
        />
      </Route>
    </Routes>
  );
}
```

This may seem like an odd choice, to make `..` operate on routes instead of URL segments, but it's a **huge** help when working with `*` routes where an indeterminate number of segments may be matched by the `*`. In these scenarios, a single `..` segment in your `<Link to>` value can essentially remove anything matched by the `*`, which lets you create more predictable links in `*` routes.

这似乎是一个奇怪的决定，让 `..` 在路由而不是 URL 段上运行，但在使用 `*` 路由时，它会带来一个**巨大**的好处，那就是当使用 `*` 路由时，`*` 可能会匹配上不确定数量的段。在这些情况下，您的 `<Link to>` 值中的单个 `..` 段实际上可以删除与 `*` 匹配的任何内容，这使您可以在 `*` 路由中创建更多可预测的链接。

```react
function App() {
  return (
    <Routes>
      <Route path=":userId">
        <Route path="messages" element={<UserMessages />} />
        <Route
          path="files/*"
          element={
            // This links to /:userId/messages, no matter
            // how many segments were matched by the *
            // 这链接到 /:userId/messages，无论有多少段被 * 匹配
            <Link to="../messages" />
          }
        />
      </Route>
    </Routes>
  );
}
```



## Use `useRoutes` instead of `react-router-config`（使用 `useRoutes` 代替 `react-router-config`）

All of the functionality from v5's `react-router-config` package has moved into core in v6. If you prefer/need to define your routes as JavaScript objects instead of using React elements, you're going to love this.

v5 的 `react-router-config` 包中的所有功能都已移至 v6 的核心包中。如果你喜欢或者需要将你的路由定义为 JavaScript 对象而非使用 React 元素，那么我保证你绝对会喜欢上它的。

```react
function App() {
  let element = useRoutes([
    // These are the same as the props you provide to <Route>
    // 这些与您提供给 <Route> 的 props 相同
    { path: "/", element: <Home /> },
    { path: "dashboard", element: <Dashboard /> },
    {
      path: "invoices",
      element: <Invoices />,
      // Nested routes use a children property, which is also
      // the same as <Route>
      // 嵌套路由使用 children 属性，这也与 <Route> 相同
      children: [
        { path: ":id", element: <Invoice /> },
        { path: "sent", element: <SentInvoices /> },
      ],
    },
    // Not found routes work as you'd expect
    { path: "*", element: <NotFound /> },
  ]);

  // The returned element will render the entire element
  // hierarchy with all the appropriate context it needs
  // 返回的元素将使用所需的所有合适的上下文来呈现整个元素层次结构
  return element;
}
```

Routes defined in this way follow all of the same semantics as `<Routes>`. In fact, `<Routes>` is really just a wrapper around `useRoutes`.

以这种方式定义的路由遵循与`<Routes>`相同的语义。事实上，`<Routes>` 实际上只是 `useRoutes` 的一个包装器。



We encourage you to give both `<Routes>` and `useRoutes` a shot and decide for yourself which one you prefer to use. Honestly, we like and use them both.

我们鼓励您试一试 `<Routes>` 和 `useRoutes`，然后自己决定更喜欢使用哪一个。老实说，我们两个都喜欢。



If you had cooked up some of your own logic around data fetching and rendering server-side, we have a low-level `matchRoutes` function available as well similar to the one we had in react-router-config.

如果您已经围绕数据获取和渲染服务器端编写了一些自己的逻辑，我们有一个低级别的 `matchRoutes` 函数可用，它与我们在 react-router-config 中的函数相似。



## Use `useNavigate` instead of `useHistory`（使用`useNavigate`而替代`useHistory`）

React Router v6 introduces a new navigation API that is synonymous with `<Link>` and provides better compatibility with suspense-enabled apps. We include both imperative and declarative versions of this API depending on your style and needs.

React Router v6 引入了一个新的导航 API，它是 `<Link>` 的同义词，并提供了与启用了suspense的应用程序更好的兼容性。为了照顾您的风格和需求，我们特意为此 API 的提供了命令式和声明式版本。

```react
// This is a React Router v5 app
// 这是一个 React Router v5 应用
import { useHistory } from "react-router-dom";

function App() {
  let history = useHistory();
  function handleClick() {
    history.push("/home");
  }
  return (
    <div>
      <button onClick={handleClick}>go home</button>
    </div>
  );
}
```

In v6, this app should be rewritten to use the `navigate` API. Most of the time this means changing `useHistory` to `useNavigate` and changing the `history.push` or `history.replace` callsite.

在 v6 中，应用程序应该被重写以便于使用 `navigate` API。大多数情况下，这意味着将 `useHistory` 需要更改为 `useNavigate` 并且还需要更改 `history.push` 或 `history.replace` 的调用点。

```react
// This is a React Router v6 app
// 这是一个 React Router v6 应用
import { useNavigate } from "react-router-dom";

function App() {
  let navigate = useNavigate();
  function handleClick() {
    navigate("/home");
  }
  return (
    <div>
      <button onClick={handleClick}>go home</button>
    </div>
  );
}
```

If you need to replace the current location instead of push a new one onto the history stack, use `navigate(to, { replace: true })`. If you need state, use `navigate(to, { state })`. You can think of the first argument to `navigate` as your `<Link to>` and the other arguments as the `replace` and `state` props. The `Link` component in v6 accepts `state` as a separate prop instead of receiving it as part of the object passed to `to` so you'll need to update your `Link` components if they are using `state`:

如果您需要替换当前位置而不是将新位置推送到历史堆栈，请使用 `navigate(to, { replace: true })`。如果你需要状态，请使用 `navigate(to, { state })`。您可以将 `navigate` 的第一个参数视为您的 `<Link to>`，将其他参数视为 `replace` 和 `state` 属性。v6 中的 `Link` 组件接受 `state` 作为单独的 prop，而不是将其作为传递给 `to` 的对象的一部分接收，因此如果您的 `Link` 组件需要使用 `state`，那么则需要更新它们：

```react
import { Link } from "react-router-dom";

// Change this:
// 修改这个：
<Link to={{ pathname: "/home", state: state }} />

// to this:
// 改为这个：
<Link to="/home" state={state} />
```

If you prefer to use a declarative API for navigation (ala v5's `Redirect` component), v6 provides a `Navigate` component. Use it like:

如果您更喜欢使用声明性 API 进行导航（例如 v5 的 `Redirect` 组件），v6 提供了一个 `Navigate` 组件。 像这样使用它：

```react
import { Navigate } from "react-router-dom";

function App() {
  return <Navigate to="/home" replace state={state} />;
}
```

**Note**: Be aware that the v5 `<Redirect />` uses `replace` logic by default (you may change it via `push` prop), on the other hand, the v6 `<Navigate />` uses `push` logic by default and you may change it via `replace` prop.

**注意**：请注意 v5 `<Redirect />` 默认使用 `replace` 逻辑（您可以通过 `push` 属性更改它），另外，v6 `<Navigate />` 默认使用 `push` 逻辑 你可以通过 `replace` 属性来改变它。

```react
// Change this:
// 修改这个：
<Redirect to="about" />
<Redirect to="home" push />

// to this:
// 改为这个：
<Navigate to="about" replace />
<Navigate to="home" />
```

If you're currently using `go`, `goBack` or `goForward` from `useHistory` to navigate backwards and forwards, you should also replace these with `navigate` with a numerical argument indicating where to move the pointer in the history stack. For example, here is some code using v5's `useHistory` hook:

如果您当前正在使用 `useHistory` 中的 `go`、`goBack` 或 `goForward` 来向后和向前导航，您还应该将它们替换为 `navigate` 然后用一个数字参数来指示在历史堆栈中指针记录的位置 。例如，这里有一些使用 v5 的 `useHistory` hook的代码：

```react
// This is a React Router v5 app
// 这是一个 React Router v5 应用程序
import { useHistory } from "react-router-dom";

function App() {
  const { go, goBack, goForward } = useHistory();

  return (
    <>
      <button onClick={() => go(-2)}>
        Go 2 pages back
      </button>
      <button onClick={goBack}>Go back</button>
      <button onClick={goForward}>Go forward</button>
      <button onClick={() => go(2)}>
        Go 2 pages forward
      </button>
    </>
  );
}
```

Here is the equivalent app with v6:

这是与 v6 等效的应用程序：

```react
// This is a React Router v6 app
// 这是一个 React Router v6 应用程序
import { useNavigate } from "react-router-dom";

function App() {
  const navigate = useNavigate();

  return (
    <>
      <button onClick={() => navigate(-2)}>
        Go 2 pages back
      </button>
      <button onClick={() => navigate(-1)}>Go back</button>
      <button onClick={() => navigate(1)}>
        Go forward
      </button>
      <button onClick={() => navigate(2)}>
        Go 2 pages forward
      </button>
    </>
  );
}
```

Again, one of the main reasons we are moving from using the `history` API directly to the `navigate` API is to provide better compatibility with React suspense. React Router v6 uses the `useTransition` hook at the root of your component hierarchy. This lets us provide a smoother experience when user interaction needs to interrupt a pending route transition, for example when they click a link to another route while a previously-clicked link is still loading. The `navigate` API is aware of the internal pending transition state and will do a REPLACE instead of a PUSH onto the history stack, so the user doesn't end up with pages in their history that never actually loaded.

同样，我们从直接使用 `history` API 转移到 `navigate` API 的主要原因之一是提供与 React suspense 更好的兼容性。React Router v6 在具体层次结构的组件根部使用 `useTransition` hook。当用户交互需要中断一个挂起的路由转换时，这能让我们能够提供更流畅的用户体验，例如当用户点击一个链接到另一个路由时，而之前点击的链接仍在加载中。`navigate` API 知道内部挂起的过渡状态，并将执行 REPLACE 而不是 PUSH 到历史堆栈里面，因此用户不会在历史记录中看到从未加载的页面。



*Note: The `<Redirect>` element from v5 is no longer supported as part of your route config (inside a `<Routes>`). This is due to upcoming changes in React that make it unsafe to alter the state of the router during the initial render. If you need to redirect immediately, you can either a) do it on your server (probably the best solution) or b) render a `<Navigate>` element in your route component. However, recognize that the navigation will happen in a `useEffect`.*

*注意：v5 中的 `<Redirect>` 元素不再支持作为路由配置的一部分（在 `<Routes>` 内）。这是由于 React 即将进行的更新使得在初始渲染期间更改路由器的状态变得不安全。如果您需要立即重定向，您可以在您的服务器上输入  a) （这可能是最好的解决方案）或者输入 b) 用于在您的路由组件中渲染一个 `<Navigate>` 元素。*



Aside from suspense compatibility, `navigate`, like `Link`, supports relative navigation. For example:

除了suspense兼容性之外，`navigate` 和 `Link` 一样，支持相对导航。 例如：

```react
// assuming we are at `/stuff`
function SomeForm() {
  let navigate = useNavigate();
  return (
    <form
      onSubmit={async (event) => {
        let newRecord = await saveDataFromForm(
          event.target
        );
        // you can build up the URL yourself
        navigate(`/stuff/${newRecord.id}`);
        // or navigate relative, just like Link
        navigate(`${newRecord.id}`);
      }}
    >
      {/* ... */}
    </form>
  );
}
```

## Remove `<Link>` `component` prop（移除 `<Link>` `component` prop）

`<Link>` no longer supports the `component` prop for overriding the returned anchor tag. There are a few reasons for this.

`<Link>` 不再支持 `component` 属性用来覆盖返回的锚标记。这么做有以下几个原因。



First of all, a `<Link>` should pretty much always render an `<a>`. If yours does not, there's a good chance your app has some serious accessibility and usability problems, and that's no good. The browsers give us a lot of nice usability features with `<a>` and we want your users to get those for free!

首先，一个`<Link>`应该总是渲染一个`<a>`。如果你不是这样的，那么你的应用程序很有可能存在一些严重的可访问性和可用性问题，这非常不好。浏览器通过 `<a>` 为我们提供了许多不错的可用性功能，我们希望您的用户也能过使用上这些功能！



That being said, maybe your app uses a CSS-in-JS library, or maybe you have a custom, fancy link component already in your design system that you'd like to render instead. The `component` prop may have worked well enough in a world before hooks, but now you can create your very own accessible `Link` component with just a few of our hooks:

话虽这么说，也许您的应用程序使用了 CSS-in-JS 库，或者您的设计系统中已经有一个自定义的、精美的链接组件你想要呈现。`component` 属性在hook出现之前已经足够好用了，但现在您可以使用我们提供的一些hook来创建自己的可访问的 `Link` 组件：

```react
import { FancyPantsLink } from "@fancy-pants/design-system";
import {
  useHref,
  useLinkClickHandler,
} from "react-router-dom";

const Link = React.forwardRef(
  (
    {
      onClick,
      replace = false,
      state,
      target,
      to,
      ...rest
    },
    ref
  ) => {
    let href = useHref(to);
    let handleClick = useLinkClickHandler(to, {
      replace,
      state,
      target,
    });

    return (
      <FancyPantsLink
        {...rest}
        href={href}
        onClick={(event) => {
          onClick?.(event);
          if (!event.defaultPrevented) {
            handleClick(event);
          }
        }}
        ref={ref}
        target={target}
      />
    );
  }
);
```

If you're using `react-router-native`, we provide `useLinkPressHandler` that works basically the same way. Just call that hook's returned function in your `Link`'s `onPress` handler and you're all set.

如果您使用的是 `react-router-native`，我们提供的 `useLinkPressHandler` 工作方式基本相同。只需在 `Link` 的 `onPress` 处理程序中调用该hook的返回函数，一切就搞定了。



## Rename `<NavLink exact>` to `<NavLink end>`（将 `<NavLink exact>` 重命名为 `<NavLink end>`）

This is a simple renaming of a prop to better align with the common practices of other libraries in the React ecosystem.

这是一个简单的 prop 重命名，以便更好地与 React 生态系统中其他库的常见做法保持一致。



## Remove `activeClassName` and `activeStyle` props from `<NavLink />`（从 `<NavLink />` 中删除 `activeClassName` 和 `activeStyle` props）

As of `v6.0.0-beta.3`, the `activeClassName` and `activeStyle` props have been removed from `NavLinkProps`. Instead, you can pass a function to either `style` or `className` that will allow you to customize the inline styling or the class string based on the component's active state.

从 `v6.0.0-beta.3` 开始，`activeClassName` 和 `activeStyle` 属性已从 `NavLinkProps` 中移除。作为替代，您可以将函数传递给 `style` 或 `className`，这将允许您根据组件的活动状态自定义内联样式或类字符串。

```react
<NavLink
  to="/messages"
- style={{ color: 'blue' }}
- activeStyle={{ color: 'green' }}
+ style={({ isActive }) => ({ color: isActive ? 'green' : 'blue' })}
>
  Messages
</NavLink>
```

```react
<NavLink
  to="/messages"
- className="nav-link"
- activeClassName="activated"
+ className={({ isActive }) => "nav-link" + (isActive ? " activated" : "")}
>
  Messages
</NavLink>
```

If you prefer to keep the v5 props, you can create your own `<NavLink />` as a wrapper component for a smoother upgrade path.

如果您更喜欢保留 v5 props，您可以创建自己的 `<NavLink />` 作为包装器组件，从而让您的升级之路更加顺畅。

```react
import * as React from "react";
import { NavLink as BaseNavLink } from "react-router-dom";

const NavLink = React.forwardRef(
  ({ activeClassName, activeStyle, ...props }, ref) => {
    return (
      <BaseNavLink
        ref={ref}
        {...props}
        className={({ isActive }) =>
          [
            props.className,
            isActive ? activeClassName : null,
          ]
            .filter(Boolean)
            .join(" ")
        }
        style={({ isActive }) => ({
          ...props.style,
          ...(isActive ? activeStyle : null),
        })}
      />
    );
  }
);
```



## Get `StaticRouter` from `react-router-dom/server`（从 `react-router-dom/server` 获取 `StaticRouter`）

The `StaticRouter` component has moved into a new bundle: `react-router-dom/server`.

`StaticRouter` 组件已移动到一个新包中：`react-router-dom/server`。

```react
// change
import { StaticRouter } from "react-router-dom";
// to
import { StaticRouter } from "react-router-dom/server";
```

This change was made both to follow more closely the convention established by the `react-dom` package and to help users understand better what a `<StaticRouter>` is for and when it should be used (on the server).

进行此更改是为了更紧密地遵循 `react-dom` 包建立的约定，并帮助用户更好地了解 `<StaticRouter>` 的用途以及何时应该使用它（在服务器上）。



## Replace `useRouteMatch` with `useMatch`（将 `useRouteMatch` 替换为 `useMatch`）

`useMatch` is very similar to v5's `useRouteMatch`, with a few key differences:

- It uses our new [path pattern matching algorithm](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#note-on-route-path-patterns)
- The pattern argument is now required
- No longer accepts an array of patterns
- When passing a pattern as an object, some of the options have been renamed to better align with other APIs in v6
  - `useRouteMatch({ strict })` is now `useMatch({ end })`
  - `useRouteMatch({ sensitive })` is now `useMatch({ caseSensitive })`
- It returns a match object with a different shape

`useMatch` 与 v5 的 `useRouteMatch` 非常相似，但有一些关键区别：

- 它使用了我们新的[路径模式匹配算法](https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#note-on-route-path-patterns)
- 现在需要模式参数
- 不再接受模式数组
- 将模式作为对象传递时，一些选项已重命名以更好地与 v6 中的其他 API 保持一致
  - `useRouteMatch({ strict })` 更名为了 `useMatch({ end })`
  - `useRouteMatch({ sensitive })` 更名为了 `useMatch({ caseSensitive })`
- 返回不同形状的匹配对象



To see the exact API of the new `useMatch` hook and its type declaration, check out our [API Reference](https://github.com/remix-run/react-router/blob/main/docs/api.md#usematch).

要查看新的`useMatch`hook的详细API以及其类型声明，请参阅我们的[API参考](https://github.com/remix-run/react-router/blob/main/docs/api.md#usematch)。



## `<Prompt>` is not currently supported（`<Prompt>` 当前不受支持）

`<Prompt>` from v5 (along with `usePrompt` and `useBlocker` from the v6 betas) are not included in the current released version of v6. We decided we'd rather ship with what we have than take even more time to nail down a feature that isn't fully baked. We will absolutely be working on adding this back in to v6 at some point in the near future, but not for our first stable release of 6.x.

v5 中的 `<Prompt>`（以及 v6 测试版中的 `usePrompt` 和 `useBlocker`）不包含在当前发布的 v6 版本中。我们决定，与其花更多时间去敲定一个还未完全成熟的功能，不如直接发布现有的功能。在不久的将来，我们肯定会把这个功能重新添加到v6中，但作为我们第一个稳定版本的6.x暂不考虑添加。



## What did we miss?（我们还漏了啥？）

Despite our best attempts at being thorough, it's very likely that we missed something. If you follow this upgrade guide and find that to be the case, please let us know. We are happy to help you figure out what to do with your v5 code to be able to upgrade and take advantage of all of the cool stuff in v6.

尽管我们已经尽了最大的努力，但很可能我们还是遗漏了一些东西。如果您遵循本升级指南并发现情况确实如此，请告知我们。我们很乐意帮助您弄清楚如何处理您的 v5 代码，以便能够升级并利用 v6 中的所有酷东西。

Good luck 🤘

祝你好运🤘



