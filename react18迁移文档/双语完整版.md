# *React v18.0* 中英文双语文档

> 原文链接：*https://zh-hans.reactjs.org/blog/2022/03/29/react-v18.html*

March 29, 2022 by The React Team

2022 年 3 月 29 日，React 团队



React 18 is now available on npm!

React 18现在已经可以在npm上使用了!



In our last post, we shared step-by-step instructions for [upgrading your app to React 18](https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html). In this post, we’ll give an overview of what’s new in React 18, and what it means for the future.

在上一篇文章中，我们分享了 [将您的应用升级到 React 18](https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html) 的分步说明。 在这篇文章中，我们将概述 React 18 的新特性，以及它对未来的意义。



Our latest major version includes out-of-the-box improvements like automatic batching, new APIs like startTransition, and streaming server-side rendering with support for Suspense.

我们最新的主要版本包括开箱即用的改进，如自动批处理、startTransition 等新 API，以及支持 Suspense 的流式服务器端渲染。



Many of the features in React 18 are built on top of our new concurrent renderer, a behind-the-scenes change that unlocks powerful new capabilities. Concurrent React is opt-in — it’s only enabled when you use a concurrent feature — but we think it will have a big impact on the way people build applications.

React 18中的许多特性都是建立在我们新的并发渲染器之上的，这是一个幕后的变化，它开启了强大的新功能。Concurrent React是一个可选功能——只有当你使用并发特性时才启用——但我们认为它会对人们构建应用程序的方式产生重大影响。



We’ve spent years researching and developing support for concurrency in React, and we’ve taken extra care to provide a gradual adoption path for existing users. Last summer, [we formed the React 18 Working Group](https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html) to gather feedback from experts in the community and ensure a smooth upgrade experience for the entire React ecosystem.

我们花了数年时间研究和开发React中对并发的支持，并且我们格外小心地为现有用户提供了一个渐进的使用路径。去年夏天，[我们成立了React 18工作组](https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html)，收集社区专家的反馈，确保整个React生态系统的升级体验顺利进行。



In case you missed it, we shared a lot of this vision at React Conf 2021:

- In [the keynote](https://www.youtube.com/watch?v=FZ0cG47msEk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa), we explain how React 18 fits into our mission to make it easy for developers to build great user experiences
- [Shruti Kapoor](https://twitter.com/shrutikapoor08) [demonstrated how to use the new features in React 18](https://www.youtube.com/watch?v=ytudH8je5ko&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=2)
- [Shaundai Person](https://twitter.com/shaundai) gave us an overview of [streaming server rendering with Suspense](https://www.youtube.com/watch?v=pj5N-Khihgc&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=3)

如果你错过了，我们在React Conf 2021上分享了很多相关的内容:

- 在[主题演讲](https://www.youtube.com/watch?v=FZ0cG47msEk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa)中，我们解释了React 18如何融入我们的使命，让开发者更容易地构建优秀的用户体验
- [Shruti Kapoor](https://twitter.com/shrutikapoor08)[演示了如何使用React 18中的新特性](https://www.youtube.com/watch?v=ytudH8je5ko&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=2)
- [Shaundai Person](https://twitter.com/shaundai) 为我们概述了[使用 Suspense 进行流式服务器渲染](https://www.youtube.com/watch?v=pj5N-Khihgc&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=3)



Below is a full overview of what to expect in this release, starting with Concurrent Rendering.

下面是这个版本的完整概述，从并发渲染开始讲。



*Note for React Native users: React 18 will ship in React Native with the New React Native Architecture. For more information, see the [React Conf keynote here](https://www.youtube.com/watch?v=FZ0cG47msEk&t=1530s).*

*React Native用户注意：React 18将在 React Native中加入新的 React Native架构。更多信息，请参阅 [React Conf 主题演讲](https://www.youtube.com/watch?v=FZ0cG47msEk&t=1530s).*



## What is Concurrent React?（什么是Concurrent React?）

The most important addition in React 18 is something we hope you never have to think about: concurrency. We think this is largely true for application developers, though the story may be a bit more complicated for library maintainers.

React 18 中最重要的新增功能是我们希望您永远不必去考虑的：并发性。 我们认为这对于应用程序的开发人员来讲基本上是一个正确的决定，尽管对于库的维护人员来讲这个情况可能就显得有点复杂了。



Concurrency is not a feature, per se. It’s a new behind-the-scenes mechanism that enables React to prepare multiple versions of your UI at the same time. You can think of concurrency as an implementation detail — it’s valuable because of the features that it unlocks. React uses sophisticated techniques in its internal implementation, like priority queues and multiple buffering. But you won’t see those concepts anywhere in our public APIs.

并发本身并不是一种新的特性。这其实是一个新的幕后机制，使React能够同时准备多个版本的UI。您可以将并发视为一个实现细节——它之所以有价值，是因为它解锁了一些功能。React在内部实现中使用了复杂的技术，比如优先级队列和多重缓存。但是你不会在我们的公共api中看到这些概念。



When we design APIs, we try to hide implementation details from developers. As a React developer, you focus on *what* you want the user experience to look like, and React handles *how* to deliver that experience. So we don’t expect React developers to know how concurrency works under the hood.

当我们设计 API 时，我们试图向开发人员隐藏实现细节。作为一名React开发者，你专注于 “*你想要什么样的*” 用户体验，，而 React 处理 *如何* 提供这种体验。所以我们不期望 React 开发人员知道并发是如何工作的。



However, Concurrent React is more important than a typical implementation detail — it’s a foundational update to React’s core rendering model. So while it’s not super important to know how concurrency works, it may be worth knowing what it is at a high level.

然而，Concurrent React 本身的作用比它的实现细节更重要——它是对 React 核心渲染模型的基础更新。 因此，虽然了解并发的工作原理并不是特别重要，但在较高的层次上了解什么是并发可能是比较有意义的。



A key property of Concurrent React is that rendering is interruptible. When you first upgrade to React 18, before adding any concurrent features, updates are rendered the same as in previous versions of React — in a single, uninterrupted, synchronous transaction. With synchronous rendering, once an update starts rendering, nothing can interrupt it until the user can see the result on screen.

Concurrent React 的一个关键特性是渲染是可中断的。 当您第一次升级到 React 18 时，在添加任何并发功能之前，更新的呈现方式与之前版本的 React 相同——在一个单一的、不间断的同步事务中。 使用同步渲染时，一旦更新开始渲染，直到用户可以在屏幕上看到结果之前没有任何东西可以中断它。



In a concurrent render, this is not always the case. React may start rendering an update, pause in the middle, then continue later. It may even abandon an in-progress render altogether. React guarantees that the UI will appear consistent even if a render is interrupted. To do this, it waits to perform DOM mutations until the end, once the entire tree has been evaluated. With this capability, React can prepare new screens in the background without blocking the main thread. This means the UI can respond immediately to user input even if it’s in the middle of a large rendering task, creating a fluid user experience.

在并发渲染中，情况并非总是如此。 React 可能会开始渲染更新，在中间暂停，然后再继续。它甚至可能完全放弃正在进行的渲染。React保证即使渲染中断，UI也会显示一致。为了做到这一点，它会等待 DOM 的变化到最后，直到完成对整个 DOM 树的评估。有了这个功能，React可以在不阻塞主线程的情况下在后台准备新屏幕显示。这意味着UI可以立即响应用户输入，即使是在大型渲染任务的中间，也可以创建流畅的用户体验。



Another example is reusable state. Concurrent React can remove sections of the UI from the screen, then add them back later while reusing the previous state. For example, when a user tabs away from a screen and back, React should be able to restore the previous screen in the same state it was in before. In an upcoming minor, we’re planning to add a new component called `<Offscreen>` that implements this pattern. Similarly, you’ll be able to use Offscreen to prepare new UI in the background so that it’s ready before the user reveals it.

另一个例子是可重用状态。Concurrent React可以从屏幕上删除一部分UI，然后在需要重用之前状态时将它们添加回来。例如，当用户从一个屏幕上移开并返回时，React 应该能够将前一个屏幕恢复到与之前相同的状态。在即将到来的小改动中，我们计划添加一个名为`<Offscreen>`的新组件来实现这个模式。类似地，你将能够使用Offscreen在后台准备新的UI，以便在用户显示它之前它就已经准备好了。



Concurrent rendering is a powerful new tool in React and most of our new features are built to take advantage of it, including Suspense, transitions, and streaming server rendering. But React 18 is just the beginning of what we aim to build on this new foundation.

并发渲染是 React 中一个强大的新工具，我们的大多数新功能都是为了利用它而构建的，包括 Suspense、过渡和流式服务器渲染。但是React 18只是我们构建此新基础目标上的一个起点而已。（备注：换句话说以后 React 的升级也会围绕着这个特性展开）



## Gradually Adopting Concurrent Features（渐进的并发特性）

Technically, concurrent rendering is a breaking change. Because concurrent rendering is interruptible, components behave slightly differently when it is enabled.

从技术上讲，并发渲染是一个突破性的变化。 因为并发渲染是可中断的，所以启用它时组件的行为会略有不同。



In our testing, we’ve upgraded thousands of components to React 18. What we’ve found is that nearly all existing components “just work” with concurrent rendering, without any changes. However, some of them may require some additional migration effort. Although the changes are usually small, you’ll still have the ability to make them at your own pace. The new rendering behavior in React 18 is **only enabled in the parts of your app that use new features.**

在我们的测试中，我们已经将数千个组件升级到了 React 18。我们发现几乎所有现有组件都“可以正常工作”并发渲染，没有任何更改。但是，其中一些可能需要一些额外的迁移工作。尽管这些变化通常很小，并且您仍然能够按照自己的步调进行更改。React 18中的新渲染行为**只会在你的一部分应用中使用新特性时启用**



The overall upgrade strategy is to get your application running on React 18 without breaking existing code. Then you can gradually start adding concurrent features at your own pace. You can use [`<StrictMode>`](https://zh-hans.reactjs.org/docs/strict-mode.html) to help surface concurrency-related bugs during development. Strict Mode doesn’t affect production behavior, but during development it will log extra warnings and double-invoke functions that are expected to be idempotent. It won’t catch everything, but it’s effective at preventing the most common types of mistakes.

整体升级策略是让您的应用程序在 React 18 上运行，而不会破坏现有代码。然后，您可以按照自己的步调逐渐开始添加并发功能。您可以使用 [`<StrictMode>`](https://zh-hans.reactjs.org/docs/strict-mode.html) 来帮助你在开发过程中发现与并发相关的错误。严格模式不会影响生产行为，但在开发过程中它会记录额外的警告和预期是幂等的双重调用函数。它不会捕获所有内容，但它可以有效地防止最常见的错误类型。



After you upgrade to React 18, you’ll be able to start using concurrent features immediately. For example, you can use startTransition to navigate between screens without blocking user input. Or useDeferredValue to throttle expensive re-renders.

升级到 React 18 后，您将能够立即开始使用并发功能。例如，您可以在屏幕之间导航时使用 startTransition ，从而不会阻塞用户输入。 或者使用DeferredValue 来限流昂贵的重渲染。



However, long term, we expect the main way you’ll add concurrency to your app is by using a concurrent-enabled library or framework. In most cases, you won’t interact with concurrent APIs directly. For example, instead of developers calling startTransition whenever they navigate to a new screen, router libraries will automatically wrap navigations in startTransition.

但是，从长远来看，我们希望您向应用程序添加并发的主要方式是使用支持并发的库或框架。在大多数情况下，您不会直接与并发 API 交互。例如，比起开发人员手动的在导航到一个新屏幕时调用startTransition，更多情况下是路由器库自动在startTransition中包装导航。



It may take some time for libraries to upgrade to be concurrent compatible. We’ve provided new APIs to make it easier for libraries to take advantage of concurrent features. In the meantime, please be patient with maintainers as we work to gradually migrate the React ecosystem.

当你将库升级为并发库时，在兼容性上面可能需要一些时间。我们提供了新的 API，使库更容易利用并发特性。同时，我们正在逐步迁移 React 生态系统的过程中，请给我们多一点时间和耐心。



For more info, see our previous post: [How to upgrade to React 18](https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html).

欲了解更多信息，请参阅我们之前的文章:[如何升级到React 18](https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html)。



## Suspense in Data Frameworks（数据框架中的Suspense ）

In React 18, you can start using Suspense for data fetching in opinionated frameworks like Relay, Next.js, Hydrogen, or Remix. Ad hoc data fetching with Suspense is technically possible, but still not recommended as a general strategy.

在React 18中，你可以开始在Relay、Next.js、Hydrogen或Remix等框架中使用Suspense 来获取数据。使用Suspense 进行临时数据抓取在技术上是可行的，但仍不推荐作为最佳实践方案。



In the future, we may expose additional primitives that could make it easier to access your data with Suspense, perhaps without the use of an opinionated framework. However, Suspense works best when it’s deeply integrated into your application’s architecture: your router, your data layer, and your server rendering environment. So even long term, we expect that libraries and frameworks will play a crucial role in the React ecosystem.

在将来，我们可能会更新出更多的原始语法来帮助你更容易的使用Suspense 来获取数据，这样一来你也许就不再需要使用上面所提到的那些框架了。然而，当 Suspense 深度集成到您的应用程序架构中时，它的效果最好，例如集成到：您的路由器、您的数据层和您的服务器渲染环境。因此从长远来看，我们预计库和框架将在 React 生态系统中发挥至关重要的作用。



As in previous versions of React, you can also use Suspense for code splitting on the client with React.lazy. But our vision for Suspense has always been about much more than loading code — the goal is to extend support for Suspense so that eventually, the same declarative Suspense fallback can handle any asynchronous operation (loading code, data, images, etc).

与之前的 React 版本一样，您还可以使用 Suspense 在客户端上通过 React.lazy 进行代码拆分。但我们对 Suspense 的期望始终不仅仅局限于加载代码层面——我们的目标是通过扩展对 Suspense 的支持，最终能够达到相同的声明性 Suspense 回退可以处理任何异步操作（包括加载代码、数据、图像等）。



## Server Components is Still in Development（服务器组件仍在开发中）

[**Server Components**](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) is an upcoming feature that allows developers to build apps that span the server and client, combining the rich interactivity of client-side apps with the improved performance of traditional server rendering. Server Components is not inherently coupled to Concurrent React, but it’s designed to work best with concurrent features like Suspense and streaming server rendering.

[**服务器组件**](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) 是一项即将推出的功能，允许开发人员构建应用程序 跨越服务器和客户端，将客户端应用程序的丰富交互性与传统服务器渲染的改进性能相结合。服务器组件并不是与 Concurrent React 耦合的，但它的设计是为了配合 Suspense 和流式服务器渲染等并发功能更好的工作。



Server Components is still experimental, but we expect to release an initial version in a minor 18.x release. In the meantime, we’re working with frameworks like Next.js, Hydrogen, and Remix to advance the proposal and get it ready for broad adoption.

服务器组件仍处于试验阶段，但我们希望在 18.x 次要版本中发布初始版本。与此同时，我们正在与像Next.js、Hydrogen和Remix这样的框架合作，以推进这个提案，并为广泛采用做好准备。



## What’s New in React 18（React 18 的新功能）



### New Feature: Automatic Batching（新功能：自动批处理）

Batching is when React groups multiple state updates into a single re-render for better performance. Without automatic batching, we only batched updates inside React event handlers. Updates inside of promises, setTimeout, native event handlers, or any other event were not batched in React by default. With automatic batching, these updates will be batched automatically:

批处理是 React 将多个状态更新分组到一个重渲染中以获得更好的性能。如果没有自动批处理，我们只能在 React 事件处理程序中批处理更新。默认情况下，Promise的状态更新、setTimeout、事件处理程序或任何其他事件都没有在 React 中批处理。使用自动批处理，这些更新将自动批处理：

```js
// Before: only React events were batched.
// 之前：只对 React 事件进行批处理。
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // React will render twice, once for each state update (no batching)
  // React 将渲染两次，状态每更新一次就会渲染一次（无批处理）
}, 1000);

// After: updates inside of timeouts, promises,
// native event handlers or any other event are batched.`
// 之后：timeouts时、promises、本地事件处理程序或任何其他事件内的更新被批处理。
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // React will only re-render once at the end (that's batching!)
  // React 只会在最后重新渲染一次（这就是批处理！）
}, 1000);
```

For more info, see this post for [Automatic batching for fewer renders in React 18](https://github.com/reactwg/react-18/discussions/21).

要了解更多信息，请参阅这篇文章[在React 18中自动批处理获取更少的渲染](https://github.com/reactwg/react-18/discussions/21)。



### New Feature: Transitions（新功能：Transitions）

A transition is a new concept in React to distinguish between urgent and non-urgent updates.

- **Urgent updates** reflect direct interaction, like typing, clicking, pressing, and so on.
- **Transition updates** transition the UI from one view to another.

过渡是 React 中的一个新概念，用于区分紧急更新和非紧急更新。

- **紧急更新**反映了直接的交互，例如输入、点击、按下等等。
- **过渡更新**用于过渡UI，将一个视图过渡到另一个视图。



Urgent updates like typing, clicking, or pressing, need immediate response to match our intuitions about how physical objects behave. Otherwise they feel “wrong”. However, transitions are different because the user doesn’t expect to see every intermediate value on screen.

输入、点击或按下等紧急更新需要立即响应，以便于符合我们对物理对象行为方式的直觉。否则他们会觉得“不对劲”。 然而，过渡更新则有所不同，因为用户并不希望在屏幕上看到两个视图切换时的每个中间值。



For example, when you select a filter in a dropdown, you expect the filter button itself to respond immediately when you click. However, the actual results may transition separately. A small delay would be imperceptible and often expected. And if you change the filter again before the results are done rendering, you only care to see the latest results.

例如，当您在下拉列表中选择过滤器时，您希望过滤器按钮本身在您单击时立即响应。然而，实际的结果可能是会分别进行过渡。轻微的延迟是察觉不到的，而且常常是预料之中的。如果在渲染结果之前再次更改过滤器，那么您只关心查看最新的结果。



Typically, for the best user experience, a single user input should result in both an urgent update and a non-urgent one. You can use startTransition API inside an input event to inform React which updates are urgent and which are “transitions”:

通常，为了获得最佳用户体验，单个用户输入应该既有紧急更新也有非紧急更新。你可以在输入事件中使用 startTransition API 来通知 React 哪些更新是紧急更新，哪些是“过渡更新”：

```js
import {startTransition} from 'react';

// Urgent: Show what was typed
// 紧急：显示输入的内容
setInputValue(input);

// Mark any state updates inside as transitions
// 将内部的任何状态更新标记为过渡更新
startTransition(() => {
  // Transition: Show the results
  // Transition: 显示结果
  setSearchQuery(input);
});
```

Updates wrapped in startTransition are handled as non-urgent and will be interrupted if more urgent updates like clicks or key presses come in. If a transition gets interrupted by the user (for example, by typing multiple characters in a row), React will throw out the stale rendering work that wasn’t finished and render only the latest update.

- `useTransition`: a hook to start transitions, including a value to track the pending state.
- `startTransition`: a method to start transitions when the hook cannot be used.

包装在 startTransition 中的更新被视为非紧急更新，如果出现更紧急的更新（如点击或按键），则会被中断。如果过渡更新被用户打断（例如，通过连续输入多个字符），React 将丢弃未完成的陈旧渲染工作并仅渲染最新更新。

- `useTransition`：一个开始过渡更新的 hook，包含一个跟踪 pending 状态的值。
- `startTransition`：一种在无法使用 hook 时要进行过渡更新的替代方法。



Transitions will opt in to concurrent rendering, which allows the update to be interrupted. If the content re-suspends, transitions also tell React to continue showing the current content while rendering the transition content in the background (see the [Suspense RFC](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md) for more info).

Transitions 将选择并发渲染，这意味着允许更新被中断。如果内容重新挂起，过渡也会告知 React 继续显示当前内容，同时在后台渲染过渡内容(更多信息请参阅[suspension RFC](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md))。



[See docs for transitions here](https://zh-hans.reactjs.org/docs/react-api.html#transitions).

[在文档中查看过渡](https://zh-hans.reactjs.org/docs/react-api.html#transitions)。



### New Suspense Features（新的Suspense功能）

Suspense lets you declaratively specify the loading state for a part of the component tree if it’s not yet ready to be displayed:

如果组件树的一部分尚未准备好显示，Suspense 允许您以声明方式指定其加载状态：

```js
<Suspense fallback={<Spinner />}>
  <Comments />
</Suspense>
```

Suspense makes the “UI loading state” a first-class declarative concept in the React programming model. This lets us build higher-level features on top of it.

Suspense 使“UI 加载状态”成为了 React 编程模型中第一级别的声明性概念。 这让我们可以在它之上构建更高级别的功能。



We introduced a limited version of Suspense several years ago. However, the only supported use case was code splitting with React.lazy, and it wasn’t supported at all when rendering on the server.

几年前，我们推出了 Suspense 的限量版。但是在当时唯一支持的就是用React.lazy 进行代码拆分，并且当时根本不支持服务器渲染。



In React 18, we’ve added support for Suspense on the server and expanded its capabilities using concurrent rendering features.

在 React 18 中，我们在服务器上添加了对 Suspense 的支持，并使用并发渲染特性扩展了它的功能。



Suspense in React 18 works best when combined with the transition API. If you suspend during a transition, React will prevent already-visible content from being replaced by a fallback. Instead, React will delay the render until enough data has loaded to prevent a bad loading state.

React 18 中的 Suspense 与transition  API 结合使用时效果最佳。如果你在过渡期间使用Suspense ，React会阻止已经可见的内容被回退替换。相反，React 还会延迟渲染，直到加载了足够的数据以防止出现错误的加载状态。



For more, see the RFC for [Suspense in React 18](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md).

更多信息，请参见RFC [React 18中的Suspense](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md)。



### New Client and Server Rendering APIs（新的客户端和服务器渲染APIs）

In this release we took the opportunity to redesign the APIs we expose for rendering on the client and server. These changes allow users to continue using the old APIs in React 17 mode while they upgrade to the new APIs in React 18.

在这个版本中，我们借此机会重新设计了我们为在客户端和服务器上公开的 API。这些更改允许用户在升级到 React 18 中的新 API 时继续使用 React 17 模式下的旧 API。



#### React DOM Client（React DOM 客户端）

These new APIs are now exported from `react-dom/client`:

- `createRoot`: New method to create a root to `render` or `unmount`. Use it instead of `ReactDOM.render`. New features in React 18 don’t work without it.
- `hydrateRoot`: New method to hydrate a server rendered application. Use it instead of `ReactDOM.hydrate` in conjunction with the new React DOM Server APIs. New features in React 18 don’t work without it.

这些新的 API 现在从 `react-dom/client` 导出：

- `createRoot`:创建用以“渲染”或“卸载”的新根部方法。 使用它来代替 `ReactDOM.render`。 没有它，React 18 中的新功能就无法工作。
- `hydrateRoot`:进行服务器端渲染时的一个新方法，使用这个方法联合新的 React DOM 服务器 API 来替代 `ReactDOM.hydrate`， 没有它，React 18 中的新功能就无法工作。



Both `createRoot` and `hydrateRoot` accept a new option called `onRecoverableError` in case you want to be notified when React recovers from errors during rendering or hydration for logging. By default, React will use [`reportError`](https://developer.mozilla.org/en-US/docs/Web/API/reportError), or `console.error` in the older browsers.

`createRoot` 和 `hydraRoot` 都接受一个名为 `onRecoverableError` 的新选项，以便于你希望在 React 渲染期间发生的错误时，收到恢复或日志记录的通知。默认情况下，React会使用[reportError ](https://developer.mozilla.org/en-US/docs/Web/API/reportError)，但在旧浏览器中则会使用console.error。



[See docs for React DOM Client here](https://zh-hans.reactjs.org/docs/react-dom-client.html).

[参阅React DOM 客户端文档](https://zh-hans.reactjs.org/docs/react-dom-client.html)。



#### React DOM Server（React DOM 服务器端）

These new APIs are now exported from `react-dom/server` and have full support for streaming Suspense on the server:

- `renderToPipeableStream`: for streaming in Node environments.
- `renderToReadableStream`: for modern edge runtime environments, such as Deno and Cloudflare workers.

这些新的api现在从`react-dom/server`导出，并完全支持服务器上的Suspense 流:

- `renderToPipeableStream`: 用于 Node 环境中的流式传输。
- `renderToReadableStream`:适用于现代比较新的运行时环境，例如 Deno 和 Cloudflare worker。



The existing `renderToString` method keeps working but is discouraged.

现有的`renderToString`方法仍然有效，但不推荐使用。



[See docs for React DOM Server here](https://zh-hans.reactjs.org/docs/react-dom-server.html).

[参见React DOM 服务器端文档](https://zh-hans.reactjs.org/docs/react-dom-server.html)。



### New Strict Mode Behaviors（新的严格模式行为）

In the future, we’d like to add a feature that allows React to add and remove sections of the UI while preserving state. For example, when a user tabs away from a screen and back, React should be able to immediately show the previous screen. To do this, React would unmount and remount trees using the same component state as before.

在未来，我们希望增加一个功能，允许React在保持状态的情况下添加和删除UI的部分。例如，当用户从一个屏幕上移开并返回时，React 应该能够立即显示上一个屏幕。为了做到这一点，React会像以前一样使用相同的组件状态卸载和重新挂载树。



This feature will give React apps better performance out-of-the-box, but requires components to be resilient to effects being mounted and destroyed multiple times. Most effects will work without any changes, but some effects assume they are only mounted or destroyed once.

这一特性将使React应用的开箱即用性能更好，但要求组件能够适应多次加载和销毁。大多数效果无需任何更改即可工作，但有些效果假定它们只能够安装或销毁一次。



To help surface these issues, React 18 introduces a new development-only check to Strict Mode. This new check will automatically unmount and remount every component, whenever a component mounts for the first time, restoring the previous state on the second mount.

为了帮助解决这些问题，React 18 为严格模式引入了一个新的仅限开发的检查。每当第一次安装组件时，此新检查将自动卸载并重新安装每个组件，并在第二次安装时恢复先前的状态。



Before this change, React would mount the component and create the effects:

在此更改之前，React 会挂载组件并创建效果：

```js
* React mounts the component.
  * Layout effects are created.
  * Effects are created.
```

With Strict Mode in React 18, React will simulate unmounting and remounting the component in development mode:

使用 React 18 中的严格模式，React 将在开发模式下模拟卸载和重新安装组件：

```js
* React mounts the component.
  * Layout effects are created.
  * Effects are created.
* React simulates unmounting the component.
  * Layout effects are destroyed.
  * Effects are destroyed.
* React simulates mounting the component with the previous state.
  * Layout effects are created.
  * Effects are created.
```

[See docs for ensuring resusable state here](https://zh-hans.reactjs.org/docs/strict-mode.html#ensuring-reusable-state).

[在这里查看确保状态复用的相关文档](https://zh-hans.reactjs.org/docs/strict-mode.html#ensuring-reusable-state)。



### New Hooks（新的 Hooks）

#### useId

`useId` is a new hook for generating unique IDs on both the client and server, while avoiding hydration mismatches. It is primarily useful for component libraries integrating with accessibility APIs that require unique IDs. This solves an issue that already exists in React 17 and below, but it’s even more important in React 18 because of how the new streaming server renderer delivers HTML out-of-order. [See docs here](https://zh-hans.reactjs.org/docs/hooks-reference.html#useid).

`useId` 是一个新的 hook，用于在客户端和服务器上生成唯一 ID，同时避免了服务器端渲染时的 id 不匹配问题。它主要用于一些集成有可访问性 API 的组件库，这些组件库可能要求唯一的 ID。这解决了 React 17 以及更低版本中所存在的问题，但在 React 18 中显得更为重要，因为新的流式服务端渲染器需要无序的渲染 HTML。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#useid).



#### useTransition

`useTransition` and `startTransition` let you mark some state updates as not urgent. Other state updates are considered urgent by default. React will allow urgent state updates (for example, updating a text input) to interrupt non-urgent state updates (for example, rendering a list of search results). [See docs here](https://zh-hans.reactjs.org/docs/react-reference.html#transitions)

`useTransition` 和 `startTransition` 让你将一些状态更新标记为不紧急。默认情况下，其他状态更新被认为是紧急的。React 将允许紧急状态更新（例如，更新文本输入）中断非紧急状态更新（例如，呈现搜索结果列表）。[参阅文档](https://zh-hans.reactjs.org/docs/react-reference.html#transitions)



#### useDeferredValue

`useDeferredValue` lets you defer re-rendering a non-urgent part of the tree. It is similar to debouncing, but has a few advantages compared to it. There is no fixed time delay, so React will attempt the deferred render right after the first render is reflected on the screen. The deferred render is interruptible and doesn’t block user input. [See docs here](https://zh-hans.reactjs.org/docs/hooks-reference.html#usedeferredvalue).

`useDeferredValue` 允许您推迟重新渲染树时的非紧急部分。它类似于防抖，但与之相比还是有一些优点。没有固定的时间延迟，因此 React 渲染首屏后会立即尝试延迟渲染。延迟渲染是可中断的，不会阻塞用户输入。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#usedeferredvalue).



#### useSyncExternalStore

`useSyncExternalStore` is a new hook that allows external stores to support concurrent reads by forcing updates to the store to be synchronous. It removes the need for useEffect when implementing subscriptions to external data sources, and is recommended for any library that integrates with state external to React. [See docs here](https://zh-hans.reactjs.org/docs/hooks-reference.html#usesyncexternalstore).

>Note
>
>`useSyncExternalStore` is intended to be used by libraries, not application code.

`useSyncExternalStore` 是一个新的 hook，它允许外部存储通过强制对存储的更新同步来支持并发读取。它在实现对外部数据源的订阅时取消了对 useEffect 的依赖，并且在使用 React 其他的外部状态管理库时推荐使用它。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#usesyncexternalstore).

> 注意：
>
> `useSyncExternalStore` 一般是用于供第三方库来使用的，而不是用于开发者的应用程序的业务代码中。



#### useInsertionEffect

`useInsertionEffect` is a new hook that allows CSS-in-JS libraries to address performance issues of injecting styles in render. Unless you’ve already built a CSS-in-JS library we don’t expect you to ever use this. This hook will run after the DOM is mutated, but before layout effects read the new layout. This solves an issue that already exists in React 17 and below, but is even more important in React 18 because React yields to the browser during concurrent rendering, giving it a chance to recalculate layout. [See docs here](https://zh-hans.reactjs.org/docs/hooks-reference.html#useinsertioneffect).

>Note
>
>`useInsertionEffect` is intended to be used by libraries, not application code.

`useInsertionEffect` 是一个新的hook，它允许 CSS-in-JS 库解决在渲染中注入样式的性能问题。除非您已经构建了 CSS-in-JS 库，否则我们不希望您使用它。这个hook会在 DOM 发生变化之后，但在读取新的布局效果之前运行。这解决了 React 17 以及更低版本中已经存在的问题，但在 React 18 中显得更为重要，因为React在并发渲染期间会将执行权交给浏览器，这就给了它重新计算布局的机会。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#useinsertioneffect).

> 注意：
>
> `useInsertionEffect`一般是用于供第三方库来使用的，而不是用于开发者的应用程序的业务代码中。



## Changelog（更新日志）

略





