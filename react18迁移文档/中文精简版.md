# *React v18.0*

> 原文链接：*https://zh-hans.reactjs.org/blog/2022/03/29/react-v18.html*

## React 18 的新功能

### 新功能：自动批处理

批处理是 React 将多个状态更新分组到一个重渲染中以获得更好的性能。如果没有自动批处理，我们只能在 React 事件处理程序中批处理更新。默认情况下，Promise的状态更新、setTimeout、事件处理程序或任何其他事件都没有在 React 中批处理。使用自动批处理，这些更新将自动批处理：

```js
// 之前：只对 React 事件进行批处理。
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // React 将渲染两次，状态每更新一次就会渲染一次（无批处理）
}, 1000);

// 之后：timeouts时、promises、本地事件处理程序或任何其他事件内的更新被批处理。
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // React 只会在最后重新渲染一次（这就是批处理！）
}, 1000);
```

要了解更多信息，请参阅这篇文章[在React 18中自动批处理获取更少的渲染](https://github.com/reactwg/react-18/discussions/21)。



### 新功能：Transitions

过渡是 React 中的一个新概念，用于区分紧急更新和非紧急更新。

- **紧急更新**反映了直接的交互，例如输入、点击、按下等等。
- **过渡更新**用于过渡UI，将一个视图过渡到另一个视图。

输入、点击或按下等紧急更新需要立即响应，以便于符合我们对物理对象行为方式的直觉。否则他们会觉得“不对劲”。 然而，过渡更新则有所不同，因为用户并不希望在屏幕上看到两个视图切换时的每个中间值。

例如，当您在下拉列表中选择过滤器时，您希望过滤器按钮本身在您单击时立即响应。然而，实际的结果可能是会分别进行过渡。轻微的延迟是察觉不到的，而且常常是预料之中的。如果在渲染结果之前再次更改过滤器，那么您只关心查看最新的结果。

通常，为了获得最佳用户体验，单个用户输入应该既有紧急更新也有非紧急更新。你可以在输入事件中使用 startTransition API 来通知 React 哪些更新是紧急更新，哪些是“过渡更新”：

```js
import {startTransition} from 'react';

// Urgent: Show what was typed
// 紧急：显示输入的内容
setInputValue(input);

// Mark any state updates inside as transitions
// 将内部的任何状态更新标记为过渡更新
startTransition(() => {
  // Transition: Show the results
  // Transition: 显示结果
  setSearchQuery(input);
});
```

包装在 startTransition 中的更新被视为非紧急更新，如果出现更紧急的更新（如点击或按键），则会被中断。如果过渡更新被用户打断（例如，通过连续输入多个字符），React 将丢弃未完成的陈旧渲染工作并仅渲染最新更新。

- `useTransition`：一个开始过渡更新的 hook，包含一个跟踪 pending 状态的值。
- `startTransition`：一种在无法使用 hook 时要进行过渡更新的替代方法。

Transitions 将选择并发渲染，这意味着允许更新被中断。如果内容重新挂起，过渡也会告知 React 继续显示当前内容，同时在后台渲染过渡内容(更多信息请参阅[suspension RFC](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md))。

[在文档中查看过渡](https://zh-hans.reactjs.org/docs/react-api.html#transitions)。



### 新的Suspense功能

如果组件树的一部分尚未准备好显示，Suspense 允许您以声明方式指定其加载状态：

```js
<Suspense fallback={<Spinner />}>
  <Comments />
</Suspense>
```

Suspense 使“UI 加载状态”成为了 React 编程模型中第一级别的声明性概念。 这让我们可以在它之上构建更高级别的功能。

几年前，我们推出了 Suspense 的限量版。但是在当时唯一支持的就是用React.lazy 进行代码拆分，并且当时根本不支持服务器渲染。

在 React 18 中，我们在服务器上添加了对 Suspense 的支持，并使用并发渲染特性扩展了它的功能。

React 18 中的 Suspense 与transition  API 结合使用时效果最佳。如果你在过渡期间使用Suspense ，React会阻止已经可见的内容被回退替换。相反，React 还会延迟渲染，直到加载了足够的数据以防止出现错误的加载状态。

更多信息，请参见RFC [React 18中的Suspense](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md)。



### 新的客户端和服务器渲染APIs

在这个版本中，我们借此机会重新设计了我们为在客户端和服务器上公开的 API。这些更改允许用户在升级到 React 18 中的新 API 时继续使用 React 17 模式下的旧 API。



#### React DOM 客户端

这些新的 API 现在从 `react-dom/client` 导出：

- `createRoot`:创建用以“渲染”或“卸载”的新根部方法。 使用它来代替 `ReactDOM.render`。 没有它，React 18 中的新功能就无法工作。
- `hydrateRoot`:进行服务器端渲染时的一个新方法，使用这个方法联合新的 React DOM 服务器 API 来替代 `ReactDOM.hydrate`， 没有它，React 18 中的新功能就无法工作。

`createRoot` 和 `hydraRoot` 都接受一个名为 `onRecoverableError` 的新选项，以便于你希望在 React 渲染期间发生的错误时，收到恢复或日志记录的通知。默认情况下，React会使用[reportError ](https://developer.mozilla.org/en-US/docs/Web/API/reportError)，但在旧浏览器中则会使用console.error。

[参阅React DOM 客户端文档](https://zh-hans.reactjs.org/docs/react-dom-client.html)。



#### React DOM 服务器端

这些新的api现在从`react-dom/server`导出，并完全支持服务器上的Suspense 流:

- `renderToPipeableStream`: 用于 Node 环境中的流式传输。
- `renderToReadableStream`:适用于现代比较新的运行时环境，例如 Deno 和 Cloudflare worker。

现有的`renderToString`方法仍然有效，但不推荐使用。

[参见React DOM 服务器端文档](https://zh-hans.reactjs.org/docs/react-dom-server.html)。



### 新的严格模式行为

在未来，我们希望增加一个功能，允许React在保持状态的情况下添加和删除UI的部分。例如，当用户从一个屏幕上移开并返回时，React 应该能够立即显示上一个屏幕。为了做到这一点，React会像以前一样使用相同的组件状态卸载和重新挂载树。

这一特性将使React应用的开箱即用性能更好，但要求组件能够适应多次加载和销毁。大多数效果无需任何更改即可工作，但有些效果假定它们只能够安装或销毁一次。

为了帮助解决这些问题，React 18 为严格模式引入了一个新的仅限开发的检查。每当第一次安装组件时，此新检查将自动卸载并重新安装每个组件，并在第二次安装时恢复先前的状态。

在此更改之前，React 会挂载组件并创建效果：

```js
* React mounts the component.
  * Layout effects are created.
  * Effects are created.
```

使用 React 18 中的严格模式，React 将在开发模式下模拟卸载和重新安装组件：

```js
* React mounts the component.
  * Layout effects are created.
  * Effects are created.
* React simulates unmounting the component.
  * Layout effects are destroyed.
  * Effects are destroyed.
* React simulates mounting the component with the previous state.
  * Layout effects are created.
  * Effects are created.
```

[在这里查看确保状态复用的相关文档](https://zh-hans.reactjs.org/docs/strict-mode.html#ensuring-reusable-state)。



### 新的 Hooks

#### useId

`useId` 是一个新的 hook，用于在客户端和服务器上生成唯一 ID，同时避免了服务器端渲染时的 id 不匹配问题。它主要用于一些集成有可访问性 API 的组件库，这些组件库可能要求唯一的 ID。这解决了 React 17 以及更低版本中所存在的问题，但在 React 18 中显得更为重要，因为新的流式服务端渲染器需要无序的渲染 HTML。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#useid).



#### useTransition

`useTransition` 和 `startTransition` 让你将一些状态更新标记为不紧急。默认情况下，其他状态更新被认为是紧急的。React 将允许紧急状态更新（例如，更新文本输入）中断非紧急状态更新（例如，呈现搜索结果列表）。[参阅文档](https://zh-hans.reactjs.org/docs/react-reference.html#transitions)



#### useDeferredValue

`useDeferredValue` 允许您推迟重新渲染树时的非紧急部分。它类似于防抖，但与之相比还是有一些优点。没有固定的时间延迟，因此 React 渲染首屏后会立即尝试延迟渲染。延迟渲染是可中断的，不会阻塞用户输入。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#usedeferredvalue).



#### useSyncExternalStore

`useSyncExternalStore` 是一个新的 hook，它允许外部存储通过强制对存储的更新同步来支持并发读取。它在实现对外部数据源的订阅时取消了对 useEffect 的依赖，并且在使用 React 其他的外部状态管理库时推荐使用它。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#usesyncexternalstore).

> 注意：
>
> `useSyncExternalStore` 一般是用于供第三方库来使用的，而不是用于开发者的应用程序的业务代码中。



#### useInsertionEffect

`useInsertionEffect` 是一个新的hook，它允许 CSS-in-JS 库解决在渲染中注入样式的性能问题。除非您已经构建了 CSS-in-JS 库，否则我们不希望您使用它。这个hook会在 DOM 发生变化之后，但在读取新的布局效果之前运行。这解决了 React 17 以及更低版本中已经存在的问题，但在 React 18 中显得更为重要，因为React在并发渲染期间会将执行权交给浏览器，这就给了它重新计算布局的机会。[参阅文档](https://zh-hans.reactjs.org/docs/hooks-reference.html#useinsertioneffect).

> 注意：
>
> `useInsertionEffect`一般是用于供第三方库来使用的，而不是用于开发者的应用程序的业务代码中。



## 更新日志）

略





